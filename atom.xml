<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>野生程序猴子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ljason.cn/"/>
  <updated>2020-04-28T16:36:31.108Z</updated>
  <id>https://ljason.cn/</id>
  
  <author>
    <name>LJason</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git——为开源项目做贡献</title>
    <link href="https://ljason.cn/Git-Fork/"/>
    <id>https://ljason.cn/Git-Fork/</id>
    <published>2020-04-27T19:08:43.000Z</published>
    <updated>2020-04-28T16:36:31.108Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在以前，<em>fork</em> 是一个贬义词，指的是某个人使开源项目向不同的方向发展，或者创建一个竞争项目，使得原项目的贡献者分裂。<br>在 GitHub，<em>fork</em> 指的是在你自己空间中创建的项目副本，这个副本允许你以一种更开放的方式对其进行修改。<br>——《<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a>》</p></blockquote><a id="more"></a><p>无论是对开源项目做贡献，还是在自己团队的项目中进行多人协作开发，了解如何正确的 <strong>派生(Fork)</strong> 并且创建 <strong>拉取请求(Pull Request，简称 PR)</strong> 都是必不可少的。</p><p>一个较为标准的流程为：</p><ol><li><strong>派生</strong> 一个项目</li><li>从 master 分支创建一个新分支</li><li>完成工作，提交 commit</li><li>创建一个 <strong>拉取请求</strong></li><li>讨论、根据实际情况改进代码</li><li>项目管理者合并或关闭拉取请求</li></ol><p>现在我们来看看具体的流程有哪些。</p><h1 id="派生一个项目"><a href="#派生一个项目" class="headerlink" title="派生一个项目"></a>派生一个项目</h1><p>无论是著名的 <a href="https://github.com/" target="_blank" rel="noopener">Github</a>，还是 <a href="https://gitlab.com/" target="_blank" rel="noopener">Gitlab</a>，项目主页面都是非常相似的。在项目主页面的右上角，找到 <strong>Fork</strong> 按钮点击一下，即可在你自己的空间中创建一个项目副本。这即是 <strong>派生</strong>。</p><p>假设用户名是 <code>user</code>，项目名为 <code>project</code>。我们接下来将这个项目 <strong>克隆(clone)</strong> 到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:user/project.git</span><br><span class="line">$ <span class="built_in">cd</span> project</span><br></pre></td></tr></table></figure><h1 id="保持项目为最新的状态"><a href="#保持项目为最新的状态" class="headerlink" title="保持项目为最新的状态"></a>保持项目为最新的状态</h1><p>如果你只是想在短期内为项目贡献，这是非必须的步骤。</p><p>但如果你打算长期为项目作出贡献，或者你自己就是开发团队的一员，则此步必不可少。</p><p>要保持项目为最新的状态，需要先添加一个上游仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加一个名为 upstream 的上游仓库地址</span></span><br><span class="line">$ git remote add upstream https://github.com/&lt;原仓库所有者&gt;/project.git</span><br><span class="line"><span class="comment"># 查看当前的仓库地址列表</span></span><br><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>现在我们已经添加了一个上游仓库的地址，接下来我们从上游仓库中 <strong>抓取(fetch)</strong> 最新的内容并 <strong>合并(merge)</strong> 进本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上游仓库抓取最新内容</span></span><br><span class="line">$ git fetch upstream</span><br><span class="line"><span class="comment"># 将上游仓库的更新合并进本地</span></span><br><span class="line">$ git merge upstream/master</span><br></pre></td></tr></table></figure><p>如果没有意外，现在本地仓库已经是最新的内容了。</p><h1 id="从-master-分支创建一个新分支"><a href="#从-master-分支创建一个新分支" class="headerlink" title="从 master 分支创建一个新分支"></a>从 master 分支创建一个新分支</h1><p>如果团队中的每个人都在同一个分支上开发，那这个分支将会变得非常混乱。针对某个特性进行修改或修复错误将会变得非常困难，特别是代码审查和错误排查也将变得难以进行。</p><p>所以在开发中合理利用 <strong>分支(branch)</strong> 是非常重要的事情。</p><p>首先，<strong>检出(checkout)</strong> 将要创建新分支的分支，这里自然就是 master 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检出 master 分支</span></span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>然后基于当前分支创建一个新分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 newfeature 的新分支</span></span><br><span class="line">$ git branch newfeature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新分支上</span></span><br><span class="line">$ git checkout newfeature</span><br></pre></td></tr></table></figure><p>很明显，<code>branch</code> 命令用于创建分支，但是并不会帮我们切换到新分支上面。如果想要切换到新分支，一样是用 <code>checkout</code> 命令。</p><p>但是大部分情况下，我们想要的都是：<em>创建并切换到新分支</em>，这有个快捷的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 newfeature 的新分支并切换到这个分支上</span></span><br><span class="line">$ git checkout -b newfeature</span><br></pre></td></tr></table></figure><p>对于分支的命名，也应遵守一些规范，比如：</p><ul><li>master：主分支，用于生产环境，一般由 develop 和 hotfix 分支合并而成</li><li>develop：主要的开发分支</li><li>feature：基于 develop 分支，开发新功能的分支</li><li>hotfix：基于 master 分支，修复 master 分支上问题的分支</li></ul><h1 id="更新、清理分支"><a href="#更新、清理分支" class="headerlink" title="更新、清理分支"></a>更新、清理分支</h1><p>当我们完成改进，也在新分支提交了一些 commit，接下来就是将改进的代码上传到远程自己的仓库里，然后创建一个 <strong>拉取请求</strong> 了。</p><p>但是在上传之前，为了让原仓库的所有者更方便的审核并测试代码，我们需要对分支进行一些操作。</p><p>在我们工作的同时，原仓库也在更新。所以这时候我们应该先更新到最新的代码，保证我们在本地做的工作不会和原仓库发生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上游仓库抓取最新内容，并将上游仓库的更新合并进本地 master 分支</span></span><br><span class="line">$ git fetch upstream</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge upstream/master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将更新应用到 newfeature 分支</span></span><br><span class="line">$ git checkout newfeature</span><br><span class="line">$ git rebase master</span><br></pre></td></tr></table></figure><p>在更新原仓库的内容之后，就是清理我们的 commit。在实际开发中，我们经常会提交一些相似的、细碎的 commit，所以我们在上传代码之前应该先清理一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout </span><br><span class="line">$ git rebase -i master</span><br></pre></td></tr></table></figure><p>现在可以上传我们的改进了。</p><h1 id="创建拉取请求"><a href="#创建拉取请求" class="headerlink" title="创建拉取请求"></a>创建拉取请求</h1><p>上传代码之后，我们就可以去自己的仓库页面点击 <strong>New pull request</strong> 按钮，即可发起一个 <strong>拉取请求</strong>。</p><p>发起之后，就可以等待原仓库的所有者对这个请求进行合并、拒绝或是发表评论了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>本文只是描述如何用较为标准的方式参与一个开源项目。其中使用到的一些东西，比如 <strong>变基(rebase)</strong>，内容太多，讲起来可能会偏离本文的主题，所以并没有过多的说明，未来可能会单独拿出来讲。</p><p>最后祝大家没有机会使用到 hotfix 分支😀。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在以前，&lt;em&gt;fork&lt;/em&gt; 是一个贬义词，指的是某个人使开源项目向不同的方向发展，或者创建一个竞争项目，使得原项目的贡献者分裂。&lt;br&gt;在 GitHub，&lt;em&gt;fork&lt;/em&gt; 指的是在你自己空间中创建的项目副本，这个副本允许你以一种更开放的方式对其进行修改。&lt;br&gt;——《&lt;a href=&quot;https://git-scm.com/book/en/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pro Git&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://ljason.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ljason.cn/tags/Git/"/>
    
      <category term="多人协作" scheme="https://ljason.cn/tags/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>在 Win10 输入颜文字(╯°□°)╯︵ ┻━┻</title>
    <link href="https://ljason.cn/Kaomoji-on-Win10/"/>
    <id>https://ljason.cn/Kaomoji-on-Win10/</id>
    <published>2019-06-07T14:58:38.000Z</published>
    <updated>2020-04-28T16:36:30.656Z</updated>
    
    <content type="html"><![CDATA[<p>　　忘了 emoji 吧，Win10 的最新更新，即 <a href="https://www.howtogeek.com/402569/everything-new-in-windows-10s-april-2019-update/" target="_blank" rel="noopener" title="Everything New in Windows 10’s May 2019 Update, Available Now">2019 年 5 月更新</a>，现在开始支持像 (ヘ･_･)ヘ┳━┳ 和 (╯°□°）╯︵ ┻━┻ 这种的 <code>颜文字</code>（<em>kaomoji</em>）了。使用隐藏的快捷键选择你喜欢的颜文字，在任何应用中输入他们——无需从网站上进行复制粘贴。</p><a id="more"></a><p>　　如果你不熟悉颜文字（<em>kaomoji</em>），它们在日本很流行。不像 emoji 是图像，颜文字更像是传统的、基于文本的表情符号。你可以在不向左倾斜的情况下理解它们，比如 <strong>:-)</strong> 是一个表情符号，<strong>^_^</strong> 是一个颜文字。</p><p>　　这个功能是 Win10 表情符号选择器的一部分。想要打开它，请在任意应用中按 <strong>Win+.</strong>（句号，实测不管中英文状态都可以打开），单击列表顶部的 <code>;-)</code> 图标来显示颜文字库。</p><p>　　如果没有看见 <code>;-)</code> 图标，则表示你还没在这台电脑上安装更新。( ´･･)ﾉ(._.`)</p><img src="/Kaomoji-on-Win10/00.webp" class=""><p>　　使用列表底部的图标浏览不同类别的颜文字，使用鼠标滚轮或拖动右侧的滚动条来浏览列表。</p><img src="/Kaomoji-on-Win10/01.webp" class=""><p>　　你也可以完全使用键盘来导航这个界面。<strong>Win+.</strong> 打开，按两次 <strong>Tab</strong> 选择顶部图标，按键盘上的右箭头 <strong>→</strong> 选择颜文字的图标，回车激活，按 <strong>Tab</strong> 将焦点移动到颜文字库，用方向键选择，最后用回车插入一个颜文字。也可以再次按 <strong>Tab</strong> 选择底栏，然后使用方向键和回车选择一种类型的颜文字。</p><p>　　现在，你可以在任何应用中快速的插入颜文字了。</p><p>( •_•)&gt;⌐■-■</p><p>(⌐■_■)</p><p>LJason 译</p><p>原文：<a href="https://www.howtogeek.com/423855/how-to-input-kaomoji-on-windows-10-%E2%95%AF%C2%B0%E2%96%A1%C2%B0%E2%95%AF%EF%B8%B5-%E2%94%BB%E2%94%81%E2%94%BB/" target="_blank" rel="noopener">How to Input Kaomoji on Windows 10 (╯°□°)╯︵ ┻━┻</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　忘了 emoji 吧，Win10 的最新更新，即 &lt;a href=&quot;https://www.howtogeek.com/402569/everything-new-in-windows-10s-april-2019-update/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; title=&quot;Everything New in Windows 10’s May 2019 Update, Available Now&quot;&gt;2019 年 5 月更新&lt;/a&gt;，现在开始支持像 (ヘ･_･)ヘ┳━┳ 和 (╯°□°）╯︵ ┻━┻ 这种的 &lt;code&gt;颜文字&lt;/code&gt;（&lt;em&gt;kaomoji&lt;/em&gt;）了。使用隐藏的快捷键选择你喜欢的颜文字，在任何应用中输入他们——无需从网站上进行复制粘贴。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>R.I.P</title>
    <link href="https://ljason.cn/RIP/"/>
    <id>https://ljason.cn/RIP/</id>
    <published>2019-06-04T12:34:06.000Z</published>
    <updated>2020-04-28T16:36:31.464Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="生活" scheme="https://ljason.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="R.I.P" scheme="https://ljason.cn/tags/R-I-P/"/>
    
  </entry>
  
  <entry>
    <title>快速加载任何网站的缓存版本</title>
    <link href="https://ljason.cn/load-the-cached-version-of-website/"/>
    <id>https://ljason.cn/load-the-cached-version-of-website/</id>
    <published>2018-08-04T14:19:26.000Z</published>
    <updated>2020-04-28T16:36:30.760Z</updated>
    
    <content type="html"><![CDATA[<p>　　无法打开某些网站的页面？只需要在 URL 前面添加 <code>cache:</code>，Google 缓存过的页面副本将立即打开。</p><a id="more"></a><img src="/load-the-cached-version-of-website/00.webp" class=""><p>　　Nick Douglas 在 <a href="https://lifehacker.com/the-easiest-way-to-load-a-broken-webpage-1827982943" target="_blank" rel="noopener" title="The Easiest Way to Load a Broken Webpage">Lifehacker</a> 上写了一篇关于这个的文章，这让我大吃一惊。如果将 Google 设置为默认的搜索引擎，这可以在任何浏览器中使用。有些网站会阻止 Google 进行缓存，除此之外这个方法很有效。</p><p>　　当某些网站关闭时，甚至在某些页面被删掉以后，缓存页面依旧有用。当你打开一个曾经存在过的网页，但是现在遇到 404 错误时，可以试试这个方法，可能会成功的出现曾经的页面。</p><p>LJason 译</p><p>原文：<a href="https://www.howtogeek.com/fyi/quickly-load-the-cached-version-of-any-website-with-this-url-trick/" target="_blank" rel="noopener">Quickly Load the Cached Version of Any Website With This URL Trick</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　无法打开某些网站的页面？只需要在 URL 前面添加 &lt;code&gt;cache:&lt;/code&gt;，Google 缓存过的页面副本将立即打开。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Chrome" scheme="https://ljason.cn/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>可以重启显卡驱动程序的 Windows 热键</title>
    <link href="https://ljason.cn/Restart-Graphics-Drivers/"/>
    <id>https://ljason.cn/Restart-Graphics-Drivers/</id>
    <published>2018-05-08T16:37:57.000Z</published>
    <updated>2020-04-28T16:36:30.744Z</updated>
    
    <content type="html"><![CDATA[<p>　　Windows 有一个秘密的快捷键，可以重启显卡驱动程序。如果你的电脑经常“冻屏”，可以在重启电脑之前试试这个快捷键，它可以修复冻屏，否则就只能强制重启电脑了。</p><p>　　这个组合快捷键将重启 Win10 和 Win8 上的图形子系统。在 Win7 上没有重启显卡驱动程序的快捷键。</p><a id="more"></a><h1 id="如何重启显卡驱动程序"><a href="#如何重启显卡驱动程序" class="headerlink" title="如何重启显卡驱动程序"></a>如何重启显卡驱动程序</h1><p>　　要重启显卡驱动程序，请按 <strong>Win+Ctrl+Shift+B</strong>。</p><p>　　屏幕会瞬间变黑，听到“嘟”的一声，然后所有内容重新出现，就像按下快捷键之前。所有的应用程序都会保持打开的状态，不会失去任何工作。</p><p>　　我们甚至在玩游戏的时候尝试了这个快捷键，当按下快捷键后，游戏保持正常运行。这是因为 Windows 只是重启了图形子系统，你的所有应用程序都保持独立，并将继续正常运行。</p><p>　　这个快捷键是 Windows 10 系统的一部分，因此它将重启 NVIDIA、AMD 和 Intel 的显卡驱动程序。无论你的电脑有什么图形硬件，它都可以生效。</p><h1 id="如何从冻屏中恢复"><a href="#如何从冻屏中恢复" class="headerlink" title="如何从冻屏中恢复"></a>如何从冻屏中恢复</h1><p>　　这不能保证修复系统卡死，但是这个快捷键可以解决由显卡驱动程序引起的冻屏。这个快捷键可以修复在玩游戏时发生的冻屏，也可以在正常使用中发生的冻屏中恢复。Win10 使用图形硬件来加速绘制桌面，甚至现代的浏览器也使用图形硬件来加速网页渲染速度。</p><p>　　如果你在全屏的游戏中看到黑屏或者无响应，可以试试重启图形显卡驱动，然后再尝试 <strong>Ctrl+Alt+Delete</strong>。你也可以尝试 <strong>Ctrl+Shift+Esc</strong> 直接打开任务管理器，或者按 <strong>Alt+Tab</strong> 或 <strong>Win+Tab</strong> 切换应用。</p><p>　　如果你的计算机没有响应上述所说的所有快捷键，那即使重启显卡驱动程序后也需要硬关机。所谓“硬关机”，即按住电脑的电源键约 10 秒，直到电脑关机，等待几秒钟后重新按下电源键开机。以这种方式关闭电脑并不好，但如果你的电脑卡死了，那这是你唯一能做的了。</p><p>　　当然，如果你的系统直接蓝屏了，那这个快捷键也于事无补。当蓝屏时，说明系统已经彻底崩溃，唯一能做的就只有重启电脑了。</p><p>LJason 译</p><p>原文：<a href="https://www.howtogeek.com/351164/secret-windows-hotkey-restarts-your-graphics-card-drivers/" target="_blank" rel="noopener">Secret Windows Hotkey Restarts Your Graphics Card Drivers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Windows 有一个秘密的快捷键，可以重启显卡驱动程序。如果你的电脑经常“冻屏”，可以在重启电脑之前试试这个快捷键，它可以修复冻屏，否则就只能强制重启电脑了。&lt;/p&gt;
&lt;p&gt;　　这个组合快捷键将重启 Win10 和 Win8 上的图形子系统。在 Win7 上没有重启显卡驱动程序的快捷键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Windows" scheme="https://ljason.cn/tags/Windows/"/>
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Git——多人协作</title>
    <link href="https://ljason.cn/Multiperson-Collaboration/"/>
    <id>https://ljason.cn/Multiperson-Collaboration/</id>
    <published>2018-03-31T08:47:17.000Z</published>
    <updated>2020-04-28T16:36:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>会一些基础的操作了，现在通过一个不太复杂的例子来看看如何进行多人协作。</p><p>一般情况下，多人协作需要至少一台机当做服务器，无论是在本机、局域网或互联网上都可以。Git 服务器一般是由管理员搭建的。我们现在将会在局域网内的一台机器上搭建一个 Git 仓库。</p><a id="more"></a><h1 id="设置一个-Git-仓库"><a href="#设置一个-Git-仓库" class="headerlink" title="设置一个 Git 仓库"></a>设置一个 Git 仓库</h1><p>非管理员可以跳过本节，无需设置服务器，直接进行多人协作。</p><p>先登陆上要设置仓库的机器，然后添加一个 git 用户，供其他用户访问：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="keyword">adduser </span>git</span><br></pre></td></tr></table></figure><p>为了不用每次都输入密码，以及更高的安全性，可以将要访问的用户的 ssh pub key 放到 <em>/home/git/.ssh/authorized_keys</em>,一个人一行。</p><h2 id="设置-ssh-key"><a href="#设置-ssh-key" class="headerlink" title="设置 ssh key"></a>设置 ssh key</h2><p>想要查看现有的 key，在本地机器（不是服务器）执行 <code>ls -al ~/.ssh</code>。然后将 <strong>authorized_keys</strong> 文件或者 <strong>.pub</strong> 结尾的文件中的内容添加进服务器的 <em>/home/git/.ssh/authorized_keys</em> 中。</p><p>如果还没有 pub key，可以新创建一个：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换邮箱</span></span><br><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="comment">// 然后输入要保存的文件，一般是直接回车就好</span></span><br><span class="line">Enter <span class="keyword">file</span> <span class="keyword">in</span> <span class="keyword">which</span> to <span class="keyword">save</span> the key：</span><br><span class="line"><span class="comment">// 这里是设置一个密码，为了以后不用每次都输入密码，所以留空，直接回车</span></span><br><span class="line">Enter passphrase</span><br></pre></td></tr></table></figure><p>创建好之后，就是把 pub key 推送到服务器了。在本地执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 替换服务器地址</span><br><span class="line">$ ssh git@xxx.xxx 'mkdir <span class="string">.ssh</span> &amp;&amp; chmod 700 <span class="string">.ssh</span> &amp;&amp; cat &gt;&gt; ~<span class="string">/.ssh/authorized_keys</span>' &lt; ~<span class="string">/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>或者将这个 <strong>id_rsa.pub</strong> 文件发给管理员添加。</p><h2 id="禁止-git-用户登录"><a href="#禁止-git-用户登录" class="headerlink" title="禁止 git 用户登录"></a>禁止 git 用户登录</h2><p>为了安全性，可以限制 git 用户登录 shell。在服务器上，编辑 <code>/etc/passwd</code>，找到：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git:</span><span class="symbol">x:</span><span class="number">1001:1001</span><span class="symbol">:</span>,,,<span class="symbol">:/home/git</span><span class="symbol">:/bin/bash</span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git:</span><span class="symbol">x:</span><span class="number">1001:1001</span><span class="symbol">:</span>,,,<span class="symbol">:/home/git</span><span class="symbol">:/usr/bin/git-shell</span></span><br></pre></td></tr></table></figure><p>在禁用 git 用户登录后，上面的 key 将无法推送，可以在搜集完 key 后再禁用。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>在服务器上，进入放仓库的目录：<code>/home/git</code>，然后初始化一个仓库：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自行更换仓库名</span></span><br><span class="line">$ sudo git init --bare <span class="keyword">name</span>.git</span><br><span class="line"><span class="comment">// 将仓库的所有者改为 git</span></span><br><span class="line">$ sudo chown -R git:git <span class="keyword">name</span>.git</span><br></pre></td></tr></table></figure><p>到这里，一个简单的 Git 仓库就已经设置完成了。</p><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><p>接下来就是激动人心的多人协作了。</p><p>现在可以将仓库克隆下来，开始多人协作：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自行更改服务器地址以及仓库名</span></span><br><span class="line">$ git clone <span class="symbol">git@</span><span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:test.git</span><br></pre></td></tr></table></figure><p>这样就克隆了一个空的仓库，然后可以在里面开始工作了。</p><p>或者，如果你在本地已有了一个仓库，想要链接这个远程仓库，可以设置：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自行更改服务器地址以及仓库名</span></span><br><span class="line">$ git remote add origin <span class="symbol">git@</span><span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:test.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><code>git remote add</code> 命令可以将服务器地址添加到当前的仓库里，便于将现在的仓库推送到服务器，<code>origin</code> 表示远程服务器。</p><p><code>-u origin master</code> 是指定操作时默认的远程分支。</p><p>这样本地仓库就链接上远程仓库，并且将所有版本记录都上传上去了。</p><h2 id="多人协作实例"><a href="#多人协作实例" class="headerlink" title="多人协作实例"></a>多人协作实例</h2><p>现在将通过一个不太难的例子来演示多人协作。</p><p>有两个人，小明和小红。一起共同开发一个小程序，服务器已经设置好了。</p><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><p>小明将这个仓库克隆下来：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="symbol">git@</span><span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random.git</span><br></pre></td></tr></table></figure><p>将会提示这是一个空仓库，所以小明创建了一个 <strong>random.c</strong> 文件并开始了编码。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rand() % <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"使用： %s &lt;数字&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">max</span> = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = random_int(<span class="built_in">max</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译一下看看能不能正常运行：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -std=c99 random.c</span><br><span class="line">$ ./<span class="selector-tag">a</span>.out</span><br><span class="line">使用： ./<span class="selector-tag">a</span><span class="selector-class">.out</span> &lt;数字&gt;</span><br><span class="line">$ ./<span class="selector-tag">a</span><span class="selector-class">.out</span> <span class="number">10</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="提交更改"><a href="#提交更改" class="headerlink" title="提交更改"></a>提交更改</h3><p>很好，现在将 <strong>random.c</strong> 添加到仓库：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> random.c</span></span><br></pre></td></tr></table></figure><p>然后看看操作的状态是否正确：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">尚无提交</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）</span><br><span class="line"></span><br><span class="line">新文件：   <span class="built_in">random</span>.c</span><br><span class="line"></span><br><span class="line">未跟踪的文件:</span><br><span class="line">  （使用 <span class="string">"git add &lt;文件&gt;..."</span> 以包含要提交的内容）</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.out</span><br></pre></td></tr></table></figure><p>有个 <strong>a.out</strong> 文件，这是一个可执行文件。作为编译生成的文件是不应该存储在版本库中的，所以小明创建一个名为 <strong>.gitignore</strong> 的文件：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可执行文件</span></span><br><span class="line">*.<span class="keyword">out</span></span><br></pre></td></tr></table></figure><p>再将 <strong>.gitignore</strong> 添加进版本控制里面：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> .gitignore</span></span><br></pre></td></tr></table></figure><p>再次查看状态，已经没有 <strong>a.out</strong> 文件了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">status</span> </span><br><span class="line">位于分支 master</span><br><span class="line"></span><br><span class="line">尚无提交</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）</span><br><span class="line"></span><br><span class="line">新文件：   .gitignore</span><br><span class="line">新文件：   <span class="built_in">random</span>.c</span><br></pre></td></tr></table></figure><p>接下来就是提交更改了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"最初版"</span></span><br></pre></td></tr></table></figure><h3 id="上传更改"><a href="#上传更改" class="headerlink" title="上传更改"></a>上传更改</h3><p>将更改提交到仓库后，小明打算上传到服务器上供小红继续开发：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><h3 id="检查历史"><a href="#检查历史" class="headerlink" title="检查历史"></a>检查历史</h3><p>现在轮到小红克隆这个版本库了：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git clone <span class="symbol">git@</span><span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random.git</span><br><span class="line">$ cd random</span><br></pre></td></tr></table></figure><p>小红想要先看看提交日志，所以她使用了 <code>log</code> 命令：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$  git log </span><br><span class="line">commit <span class="number">3f</span>59af20a7621f9d670da046da6f805464f6a379 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: 小明 &lt;小明@gmail.com&gt;</span><br><span class="line">Date:   Fri Mar <span class="number">30</span> <span class="number">10</span>:<span class="number">53</span>:<span class="number">59</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    最初版</span><br></pre></td></tr></table></figure><p>经过一番检查和调试，小红发现这个随机数生成器从不初始化，每次生成的都是一样的数字。小红进行了一点修改：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rand() % <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"使用： %s &lt;数字&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">max</span> = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">int</span> result = random_int(<span class="built_in">max</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进过一番调试，每次生成的都不一样了，可以进行提交了。看看需要什么操作：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">位于分支 <span class="literal">master</span></span><br><span class="line">您的分支与上游分支 'origin/<span class="literal">master</span>' 一致。</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 <span class="string">"git add &lt;文件&gt;..."</span> 更新要提交的内容）</span><br><span class="line">  （使用 <span class="string">"git checkout -- &lt;文件&gt;..."</span> 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">修改：     random.c</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 <span class="string">"git add"</span> 和/或 <span class="string">"git commit -a"</span>）</span><br></pre></td></tr></table></figure><p>git 已经知道 <strong>random.c</strong> 被修改了。小红想要通过 <code>diff</code> 命令查看更详细的内容：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/<span class="built_in">random</span>.c b/<span class="built_in">random</span>.c</span><br><span class="line">index b831e09.<span class="number">.636</span>b28c <span class="number">100644</span></span><br><span class="line">--- a/<span class="built_in">random</span>.c</span><br><span class="line">+++ b/<span class="built_in">random</span>.c</span><br><span class="line">@@ <span class="number">-1</span>,<span class="number">5</span> +<span class="number">1</span>,<span class="number">6</span> @@</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">random_int</span><span class="params">(<span class="keyword">int</span> <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">@@ <span class="number">-16</span>,<span class="number">6</span> +<span class="number">17</span>,<span class="number">7</span> @@ <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">   <span class="keyword">int</span> <span class="built_in">max</span> </span>= atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">+  srand(time(<span class="literal">NULL</span>));</span><br><span class="line">   <span class="keyword">int</span> result = random_int(<span class="built_in">max</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br></pre></td></tr></table></figure><p>现在可以添加、提交并且推送到服务器了：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> random.c</span><br><span class="line">git commit -m <span class="string">"初始化随机数"</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><h3 id="重命名和移动文件"><a href="#重命名和移动文件" class="headerlink" title="重命名和移动文件"></a>重命名和移动文件</h3><p>小明打算重构一下，所以决定将所有源码文件移动到 <code>src/</code> 目录下：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mkdir src</span><br><span class="line"><span class="variable">$ </span>git mv random.c src/</span><br><span class="line"><span class="variable">$ </span>git status </span><br><span class="line">位于分支 master</span><br><span class="line">您的分支与上游分支 <span class="string">'origin/master'</span> 一致。</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">"git reset HEAD &lt;文件&gt;..."</span> 以取消暂存）</span><br><span class="line"></span><br><span class="line">重命名：   random.c -&gt; src/random.c</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"重构文件"</span></span><br></pre></td></tr></table></figure><p>然后小明决定为项目创建一个 <strong>Makefile</strong> 和 <strong>README</strong> 文件：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat Makefile</span><br><span class="line"><span class="bullet">all:: </span>random</span><br><span class="line"></span><br><span class="line">CC=gcc</span><br><span class="line">CFLAGS=-std=c99 -Wall -Wextra</span><br><span class="line"></span><br><span class="line">random:</span><br><span class="line"><span class="code">$(CC) $(CFLAGS) src/random.c</span></span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"><span class="code">$(RM) *.o random</span></span><br><span class="line"></span><br><span class="line"><span class="title">.PHONY: all clean</span></span><br><span class="line"></span><br><span class="line">$ cat README</span><br><span class="line">随机数生成</span><br><span class="line">==========</span><br><span class="line"></span><br><span class="line">在给定的最大数内生成随机整数。</span><br></pre></td></tr></table></figure><p>然后将这两个文件添加并提交：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> Makefile README</span></span><br><span class="line">$ git commit -m <span class="string">"添加 Makefile 和 README 文件"</span></span><br></pre></td></tr></table></figure><p>然后小明决定将 <strong>random.c</strong> 文件重命名为 <strong>rand.c</strong>：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv src/random.<span class="keyword">c</span> src/rand.<span class="keyword">c</span></span><br></pre></td></tr></table></figure><p>同时，<strong>Makefile</strong> 也需要更改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/Makefile b/Makefile</span><br><span class="line">index 41c6682..597d818 100644</span><br><span class="line"><span class="comment">--- a/Makefile</span></span><br><span class="line"><span class="comment">+++ b/Makefile</span></span><br><span class="line"><span class="meta">@@ -1,12 +1,12 @@</span></span><br><span class="line"><span class="deletion">-all:: random</span></span><br><span class="line"><span class="addition">+all:: rand</span></span><br><span class="line"> </span><br><span class="line"> CC=gcc</span><br><span class="line"> CFLAGS=-std=c99 -Wall -Wextra</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-random:</span></span><br><span class="line"><span class="deletion">-       $(CC) $(CFLAGS) src/random.c</span></span><br><span class="line"><span class="addition">+rand:</span></span><br><span class="line"><span class="addition">+       $(CC) $(CFLAGS) src/rand.c</span></span><br><span class="line"> </span><br><span class="line"> clean:</span><br><span class="line"><span class="deletion">-       $(RM) *.o random</span></span><br><span class="line"><span class="addition">+       $(RM) *.o rand</span></span><br><span class="line"> </span><br><span class="line"> .PHONY: all clean</span><br><span class="line"></span><br><span class="line">$ git add Makefile</span><br><span class="line">$ git commit -m "重命名文件"</span><br></pre></td></tr></table></figure><h3 id="更新存储库（合并）"><a href="#更新存储库（合并）" class="headerlink" title="更新存储库（合并）"></a>更新存储库（合并）</h3><p>提交完以后，小明准备推送这些更改到服务器：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">To 192.168.2.103:random.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line"><span class="keyword">error: </span>无法推送一些引用到 'git@192.168.2.103:random.git'</span><br><span class="line">提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外</span><br><span class="line">提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更</span><br><span class="line">提示：（如 'git pull ...'）。</span><br><span class="line">提示：详见 'git push --help' 中的 'Note about fast-forwards' 小节。</span><br></pre></td></tr></table></figure><p>推送失败，这是因为小红已经先推送了一个版本。小明需要先将小红推送的内容拉取下来（需要添加提交信息）：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: <span class="number">3</span>, done.</span><br><span class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br><span class="line">remote: Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">展开对象中: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), 完成.</span><br><span class="line">来自 <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random</span><br><span class="line">   <span class="number">3f</span>59af2.<span class="number">.4f</span>42481  master     -&gt; origin/master</span><br><span class="line">自动合并 src/rand.c</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line"> src/rand.c | <span class="number">2</span> ++</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span><br></pre></td></tr></table></figure><p><code>pull</code> 命令是获取服务器上最新的版本，并且会自动与本地的版本合并，并且提交合并。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show</span><br><span class="line">commit dd5316ec3e192129a9283eaf38208a15ce0b070f (HEAD -&gt; master)</span><br><span class="line">Merge: <span class="number">5616</span>d0c <span class="number">4f</span>42481</span><br><span class="line">Author: 小明 &lt;小明@gmail.com&gt;</span><br><span class="line">Date:   Fri Mar <span class="number">30</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'master'</span> of <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random</span><br><span class="line">    </span><br><span class="line">    合并小红的版本</span><br></pre></td></tr></table></figure><p><code>show</code> 命令是显示当前的提交。看上去像是合并成功了，并且没有任何问题。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>小红和小明决定发布这个项目，所以小明创建了一个标签，以便可以更好的访问、引用发布的版本。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a -m <span class="string">"random v0.1"</span> v0<span class="number">.1</span></span><br><span class="line">$ git tag --list</span><br><span class="line">v0<span class="number">.1</span></span><br><span class="line">$ git log <span class="number">-1</span></span><br><span class="line">Merge: <span class="number">5616</span>d0c <span class="number">4f</span>42481</span><br><span class="line">Author: 小明 &lt;小明@gmail.com&gt;</span><br><span class="line">Date:   Fri Mar <span class="number">30</span> <span class="number">12</span>:<span class="number">35</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">'master'</span> of <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random</span><br><span class="line">    </span><br><span class="line">    合并小红的版本</span><br></pre></td></tr></table></figure><p>现在，这个标签仅在小明的本地库中，接下来就是把所有更改全都推送到服务器上：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin tag v0<span class="number">.1</span></span><br><span class="line">对象计数中: <span class="number">15</span>, 完成.</span><br><span class="line">Delta compression using up to <span class="number">8</span> threads.</span><br><span class="line">压缩对象中: <span class="number">100</span>% (<span class="number">12</span>/<span class="number">12</span>), 完成.</span><br><span class="line">写入对象中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), <span class="number">1.70</span> KiB | <span class="number">579.00</span> KiB/s, 完成.</span><br><span class="line">Total <span class="number">15</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random.git</span><br><span class="line"> * [new tag]         v0<span class="number">.1</span> -&gt; v0<span class="number">.1</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>小红更新仓库以获取 <code>v0.1</code> 标签，并从最新的版本库继续：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: 对象计数中: <span class="number">15</span>, 完成.</span><br><span class="line">remote: 压缩对象中: <span class="number">100</span>% (<span class="number">12</span>/<span class="number">12</span>), 完成.</span><br><span class="line">remote: Total <span class="number">15</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">展开对象中: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), 完成.</span><br><span class="line">来自 <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random</span><br><span class="line">   <span class="number">6e6</span>e562.<span class="number">.05</span>db770  master     -&gt; origin/master</span><br><span class="line"> * [新标签]          v0<span class="number">.1</span>       -&gt; v0<span class="number">.1</span></span><br><span class="line">更新 <span class="number">6e6</span>e562.<span class="number">.05</span>db770</span><br><span class="line">Fast-forward</span><br><span class="line"> Makefile               | <span class="number">12</span> ++++++++++++</span><br><span class="line"> README                 |  <span class="number">4</span> ++++</span><br><span class="line"> random.c =&gt; src/rand.c |  <span class="number">0</span></span><br><span class="line"> <span class="number">3</span> files changed, <span class="number">16</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> Makefile</span><br><span class="line"> create mode <span class="number">100644</span> README</span><br><span class="line"> rename random.c =&gt; src/rand.c (<span class="number">100</span>%)</span><br></pre></td></tr></table></figure><h3 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h3><p>小红现在决定将一个伪随机数生成器的初始化提取到一个单独的方法中，这样初始化和生成随机数都被封装起来，让未来的修改更加容易。添加 <code>init_rand()</code>：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff <span class="comment">--git a/src/rand.c b/src/rand.c</span></span><br><span class="line"><span class="keyword">index</span> <span class="number">636</span>b28c..fec25cb <span class="number">100644</span></span><br><span class="line"><span class="comment">--- a/src/rand.c</span></span><br><span class="line">+++ b/src/rand.c</span><br><span class="line">@@ <span class="number">-2</span>,<span class="number">6</span> +<span class="number">2</span>,<span class="number">11</span> @@</span><br><span class="line"> #<span class="keyword">include</span> &lt;stdlib.h&gt;</span><br><span class="line"> #<span class="keyword">include</span> &lt;<span class="type">time</span>.h&gt;</span><br><span class="line"> </span><br><span class="line">+<span class="type">void</span> init_rand(<span class="type">void</span>)</span><br><span class="line">+&#123;</span><br><span class="line">+  srand(<span class="type">time</span>(<span class="keyword">NULL</span>));</span><br><span class="line">+&#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> random_int(<span class="type">int</span> max)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span> rand() % max;</span><br><span class="line">@@ <span class="number">-17</span>,<span class="number">7</span> +<span class="number">22</span>,<span class="number">7</span> @@ <span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> max = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">-  srand(<span class="type">time</span>(<span class="keyword">NULL</span>));</span><br><span class="line">+  init_rand();</span><br><span class="line">   <span class="type">int</span> result = random_int(max);</span><br><span class="line">   printf("%d\n", result);</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">add</span> src/rand.c</span><br><span class="line">$ git <span class="keyword">commit</span> -m "提取随机生成器的初始化"</span><br></pre></td></tr></table></figure><p>与此同时，小明发现 <code>rand()</code> 函数的文档说此方法是一个弱伪随机生成器。所以他决定添加注释：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/src/<span class="keyword">rand</span>.c b/src/<span class="keyword">rand</span>.c</span><br><span class="line">index <span class="number">636</span>b28c..c18c11e <span class="number">100644</span></span><br><span class="line">--- a/src/<span class="keyword">rand</span>.c</span><br><span class="line">+++ b/src/<span class="keyword">rand</span>.c</span><br><span class="line">@@ <span class="number">-2</span>,<span class="number">6</span> +<span class="number">2</span>,<span class="number">7</span> @@</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> #include &lt;time.h&gt;</span><br><span class="line"> </span><br><span class="line">+<span class="comment">// 考虑使用更好的随机生成器</span></span><br><span class="line"> <span class="keyword">int</span> random_int(<span class="keyword">int</span> <span class="keyword">max</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">rand</span>() % <span class="keyword">max</span>;</span><br><span class="line"></span><br><span class="line">$ git add src/<span class="keyword">rand</span>.c</span><br><span class="line">$ git commit -m <span class="string">"添加注释"</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>这时候，小红也准备推送了，但是被拒绝：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">To 192.168.2.103:random.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line"><span class="keyword">error: </span>无法推送一些引用到 'git@192.168.2.103:random.git'</span><br><span class="line">提示：更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外</span><br><span class="line">提示：一个仓库已向该引用进行了推送。再次推送前，您可能需要先整合远程变更</span><br><span class="line">提示：（如 'git pull ...'）。</span><br><span class="line">提示：详见 'git push --help' 中的 'Note about fast-forwards' 小节。</span><br></pre></td></tr></table></figure><p>小明已经推送了一个版本，小红必须先 <code>pull</code> 拉取到最新的版本再合并，才可以继续推送：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: 对象计数中: <span class="number">4</span>, 完成.</span><br><span class="line">remote: 压缩对象中: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), 完成.</span><br><span class="line">remote: Total <span class="number">4</span> (delta <span class="number">2</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">展开对象中: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), 完成.</span><br><span class="line">来自 <span class="number">192.168</span><span class="number">.2</span><span class="number">.103</span>:random</span><br><span class="line">   <span class="number">05</span>db770..e20781e  master     -&gt; origin/master</span><br><span class="line">自动合并 src/rand.c</span><br><span class="line">冲突（内容）：合并冲突于 src/rand.c</span><br><span class="line">自动合并失败，修正冲突然后提交修正的结果。</span><br></pre></td></tr></table></figure><p>这次合并失败了，Git 无法自动合并两人的更改。提示有冲突，所以小红决定在编辑器中打开 <strong>src/rand.c</strong> 文件来检查：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="variable">HEAD</span></span><br><span class="line"><span class="variable">void</span> <span class="function"><span class="title">init_rand</span>(<span class="variable">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">srand</span>(<span class="title"><span class="built_in">time</span></span>(<span class="variable"><span class="literal">NULL</span></span>));</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">=======</span></span><br><span class="line"><span class="function"><span class="comment">// 考虑使用更好的随机生成器</span></span></span><br><span class="line"><span class="function">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="variable">e20781e46d20ffcd2b79c5c537823ffc9deaa102</span></span></span><br></pre></td></tr></table></figure><p>Git 同时将小红的代码（*&lt;&lt;&lt;&lt;&lt;&lt;&lt;* 和 <em>=======</em> 之间）和小明的代码（<em>=======</em> 和 <em>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</em> 之间）都包含了。只有两个代码块分开时自动合并才会成功，因为没有分开，所以这次合并失败了。小红的 <code>init_rand()</code> 函数可以在小明的注释之前，所以小红这样更改：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff <span class="comment">--cc src/rand.c</span></span><br><span class="line"><span class="keyword">index</span> fec25cb,c18c11e.<span class="number">.0000000</span></span><br><span class="line"><span class="comment">--- a/src/rand.c</span></span><br><span class="line">+++ b/src/rand.c</span><br><span class="line">@@@ <span class="number">-2</span>,<span class="number">11</span> <span class="number">-2</span>,<span class="number">7</span> +<span class="number">2</span>,<span class="number">12</span> @@@</span><br><span class="line">  #<span class="keyword">include</span> &lt;stdlib.h&gt;</span><br><span class="line">  #<span class="keyword">include</span> &lt;<span class="type">time</span>.h&gt;</span><br><span class="line">  </span><br><span class="line"> +<span class="type">void</span> init_rand(<span class="type">void</span>)</span><br><span class="line"> +&#123;</span><br><span class="line"> +  srand(<span class="type">time</span>(<span class="keyword">NULL</span>));</span><br><span class="line"> +&#125;</span><br><span class="line"> +</span><br><span class="line">+ // 考虑使用更好的随机生成器</span><br><span class="line">  <span class="type">int</span> random_int(<span class="type">int</span> max)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % max;</span><br></pre></td></tr></table></figure><p>这样应该就解决完问题了，然后再添加并提交：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git add src/rand.c</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"合并： init_rand() + 注释"</span></span><br><span class="line"><span class="variable">$ </span>git push</span><br></pre></td></tr></table></figure><p><code>push</code> 已经没有任何问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;会一些基础的操作了，现在通过一个不太复杂的例子来看看如何进行多人协作。&lt;/p&gt;
&lt;p&gt;一般情况下，多人协作需要至少一台机当做服务器，无论是在本机、局域网或互联网上都可以。Git 服务器一般是由管理员搭建的。我们现在将会在局域网内的一台机器上搭建一个 Git 仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://ljason.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ljason.cn/tags/Git/"/>
    
      <category term="仓库" scheme="https://ljason.cn/tags/%E4%BB%93%E5%BA%93/"/>
    
      <category term="多人协作" scheme="https://ljason.cn/tags/%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>什么是 API？</title>
    <link href="https://ljason.cn/What-Is-An-API/"/>
    <id>https://ljason.cn/What-Is-An-API/</id>
    <published>2018-03-23T03:04:26.000Z</published>
    <updated>2020-04-28T16:36:30.800Z</updated>
    
    <content type="html"><![CDATA[<p>　　你可能早就看过 ”<strong>API</strong>“ 这个词了。操作系统、浏览器和应用程序在更新时通常都会宣布新的 API，但什么是 API 呢？</p><a id="more"></a><h1 id="应用程序接口"><a href="#应用程序接口" class="headerlink" title="应用程序接口"></a>应用程序接口</h1><p>　　<strong>API</strong> 是 <code>应用程序接口</code>（<em>Application Programming Interface</em>）的首字母缩写。</p><p>　　API 就像餐馆里的菜单一样，菜单提供了你在餐馆可以点的菜以及每道菜的描述。当你点了菜以后，餐厅的厨房会做好你点的菜，并把菜端上来。你不知道餐厅是如何制作食物的，而你也并不需要知道。</p><p>　　同样的，API 列出了开发人员可以使用的一系列操作，并说明了这些操作。比如：开发人员并不一定需要知道操作系统是如何进行 “另存为” 操作的，只需要知道如何调用 “另存为” 就行了。</p><p>　　这并不是一个完美的比喻，因为开发人员可能必须向 API 提供他们自己的数据才能获得结果。所以这或许更像是一个高级餐厅，你可以向餐厅提供你自己的配料来制作食物。</p><p>　　大致就是这样，API 允许开发人员利用平台的实现来完成基本工作，从而节省时间。这有助于减少开发人员需要创建的代码量，还有助于在同一平台为应用程序创建更高的一致性。API 还可以控制对硬件和软件资源的访问。</p><h1 id="API-使开发人员的生活更轻松"><a href="#API-使开发人员的生活更轻松" class="headerlink" title="API 使开发人员的生活更轻松"></a>API 使开发人员的生活更轻松</h1><p>　　假设你想为 Android 开发应用程序，Google 的 Android 系统提供了大量的 <a href="https://developer.android.com/reference/packages.html" target="_blank" rel="noopener">API</a>，就像其他操作系统一样，让你的开发变得更加轻松。</p><p>　　比如：如果你想要嵌入 Web 浏览器以显示一个或多个网页，并不需要为你的应用程序从头开始编写自己的 Web 浏览器。你可以使用 <a href="https://developer.android.com/reference/android/webkit/WebView.html" target="_blank" rel="noopener">WebView</a> API 在应用程序中嵌入 webkit 对象。</p><p>　　如果你想从相机捕捉照片或视频，则无需编写自己的相机界面，你可以使用相机 API 将 Android 内置的相机嵌入到你的应用程序中。如果不存在这个 API，开发人员将不得不创建自己的相机软件并解析摄像头的输入。但是 Android 系统的开发人员已经完成了这些艰苦的工作，因此开发人员可以使用相机 API 嵌入相机，然后开始构建应用程序。而且，当 Google 改进相机 API 时，所有依赖它的应用程序都会自动利用这一改进。</p><p>　　这适用于每个平台。你想在 Windows 上创建一个对话框？有这个 <a href="https://msdn.microsoft.com/library/windows/desktop/hh920508.aspx" target="_blank" rel="noopener">API</a> ；想在 Android 上支持指纹验证？这也有 <a href="https://developer.android.com/about/versions/marshmallow/android-6.0.html#fingerprint-authentication" target="_blank" rel="noopener" title="指纹身份验证">API</a>，因此你不必为每个不同的 Android 设备制造商测试指纹传感器。开发人员不必一遍又一遍的重复造轮子。</p><h1 id="API-控制着对资源的访问"><a href="#API-控制着对资源的访问" class="headerlink" title="API 控制着对资源的访问"></a>API 控制着对资源的访问</h1><p>　　API 也用于控制对硬件设备和软件功能的访问，应用程序不一样具有使用许可。这就是为什么 API 经常在安全性方面发挥重要作用。</p><p>　　比如，如果你曾今访问过某个网站并在浏览器中看到该网站要求查看你的确切位置的消息，这是该网站正在尝试在你的浏览器中使用地理定位 API。Web 浏览器公开这样的 API，以便 Web 开发人员轻松访问你的位置——他们可以询问 “你在哪？”，浏览器便通过访问 GPS 或附近的 Wi-Fi 网络来查找你的物理位置。</p><img src="/What-Is-An-API/00.webp" class=""><p>　　但是，浏览器也会通过 API 公开这些信息，因为可以控制对其的访问。当网站想要访问你的确切位置时，唯一的方法就是通过位置 API 来获取。而且，当一个网站试图使用它时，你——用户——可以选择允许或拒绝这个请求。访问 GPS 传感器等硬件资源唯一的方法便是通过 API，因此浏览器可以控制对硬件的访问并限制应用程序可以执行的操作。</p><p>　　在 iOS 和 Android 等现代移动操作系统中也使用相同的原理，可以通过控制其中的应用程序对 API 的访问来实施权限管理。比如，如果开发人员尝试通过相机 API 访问相机，则可以拒绝权限请求，该应用则无法访问设备的相机。</p><p>使用权限的文件系统（如在 Windows、Mac 和 Linux 上执行的权限）具有由文件系统 API 执行的权限。典型的应用程序不能直接访问原始物理硬盘。相反，应用程序必须通过 API 访问文件。</p><h1 id="API-用于服务之间的通信"><a href="#API-用于服务之间的通信" class="headerlink" title="API 用于服务之间的通信"></a>API 用于服务之间的通信</h1><p>　　API 也被用于各种途径。比如：经常可以看到嵌入 Google 地图的网站，该网站就是使用 Google 地图 API 实现的。Google 向 Web 开发者公开这样的 API，然后他们可以使用这些 API 在他们网站上实现复杂的对象。如果这样的 API 不存在，开发者可能必须创建他们自己的地图并提供他们自己的地图数据，以便在网站上放置一些交互式地图。</p><p>　　而且，因为这是一个 API，Google 可以控制第三方网站对 Google 地图的访问，确保他们以一致的方式使用它，而不是试图混乱地嵌入显示 Google 地图网站的框架中。</p><p>　　这适用于许多不同的在线服务。有 API 用于请求 Google 翻译，或者在网站上嵌入来自 Twitter 或 Facebook 的评论和推文。</p><p>　　<a href="https://zh.wikipedia.org/wiki/%E5%BC%80%E6%94%BE%E6%8E%88%E6%9D%83" target="_blank" rel="noopener" title="维基百科：开放授权">开放授权</a> 还定义了许多 API，允许你使用其他服务登录网站。比如：使用你的 Facebook、Google 或 Twitter 账户登录到新网站，而无需为该网站创建新的用户账户。API 是定义开发人员如何与服务进行通讯的标准协议，以及开发人员期望收到的输出类型。</p><p>　　如果你已经了解了这点，你就会对 API 的内容有更好的了解。最后，除非你是开发人员，否则你并不需要知道 API 是什么。但是，如果你看到软件平台或服务为各种硬件或服务添加了新的 API，开发人员应该会更容易应用这些功能。</p><p>LJason 译</p><p>原文：<a href="https://www.howtogeek.com/343877/what-is-an-api/" target="_blank" rel="noopener">What Is an API?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　你可能早就看过 ”&lt;strong&gt;API&lt;/strong&gt;“ 这个词了。操作系统、浏览器和应用程序在更新时通常都会宣布新的 API，但什么是 API 呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="API" scheme="https://ljason.cn/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Git——基础操作</title>
    <link href="https://ljason.cn/Basic-Operation/"/>
    <id>https://ljason.cn/Basic-Operation/</id>
    <published>2018-03-01T14:37:55.000Z</published>
    <updated>2020-04-28T16:36:31.260Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲了如何安装和配置 Git，现在来开始了解如何使用 Git。</p><a id="more"></a><p>我们通过一个简单的例子来学习。</p><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>首先在命令行里 <strong>cd</strong> 进入需要进行版本控制的目录，为了演示，我将新建一个目录，然后进入目录。</p><p>输入 <strong>git init</strong> 进行初始化。</p><img src="/Basic-Operation/00.webp" class=""><p>这样就成功的初始化了一个 Git 仓库。</p><p>所谓仓库（repository），其实就是一个目录，里面的文件就像一个个物品，当文件更新时，新版本就摆出来，然后把旧版本收起来放在一个专门的地方。</p><p>这个地方就是上图中的 <strong>.git</strong> 目录。Linux 默认是不显示隐藏文件及目录的（在 Linux 中，文件或目录的名字前面加个 <strong>.</strong> 就是隐藏了），可以执行 <code>ls -a</code> 查看。.git 目录里面保存着文件所有的历史记录。如果把它删了，所有文件的历史记录都将消失，平时没事不要去动它。</p><p>我们来看看这个仓库的状态，执行 <code>git status</code>。</p><img src="/Basic-Operation/01.webp" class=""><p><code>git status</code> 是查看当前仓库状态的命令，可以看见现在还没有任何文件在里面，所以显示无文件要提交。</p><h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><p>现在我们在仓库里面创建一个文本文件。我创建了一个 <strong>first.txt</strong> 文件，内容是 <code>第一版内容</code>。</p><img src="/Basic-Operation/02.webp" class=""><p>再次执行 <code>git status</code>：</p><img src="/Basic-Operation/03.webp" class=""><p>可以看见有 <em>未跟踪的文件</em>。现在执行 <code>git add first.txt</code>，将 <strong>first.txt</strong> 文件添加到仓库。</p><p>不是说把文件放在仓库（目录）里面就算添加了，而是需要 <code>git add</code>。这个操作就相当于登记，只有在仓库里面登记了，这个被登记的文件才真正属于这个仓库。</p><p>现在我们再次执行 <code>git status</code>：</p><img src="/Basic-Operation/04.webp" class=""><p>可以看见新文件需要提交变更。</p><p>如果想提交某个文件夹，直接 <code>git add 目录名</code>；如果想提交当前目录下的所有文件，可以 <code>git add .</code>。</p><h2 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h2><p>提交变更可以使用 <code>git commit</code> 命令，但最好附上一段说明信息，比如：</p><img src="/Basic-Operation/05.webp" class=""><p>附上说明信息是一个很好的习惯，当需要还原前面版本的时候可以很容易知道需要还原到哪个版本。</p><h2 id="再次修改并提交"><a href="#再次修改并提交" class="headerlink" title="再次修改并提交"></a>再次修改并提交</h2><p>提交完之后，再次修改文件，比如修改成 <code>第二版内容</code>。</p><p><code>git status</code> 可以看见 <strong>first.txt</strong> 是修改状态。让我们再次添加修改：<code>git add first.txt</code>，可以看见红字变绿了，接下来第二次提交。</p><img src="/Basic-Operation/06.webp" class=""><h2 id="检出版本"><a href="#检出版本" class="headerlink" title="检出版本"></a>检出版本</h2><p>现在发现第二版写错了，想回到上一版重新写。</p><p>可以先看看我们提交了哪些版本：<code>git log</code>。</p><img src="/Basic-Operation/07.webp" class=""><p><code>git log</code> 是显示仓库的历史记录。上图我们可以看见有一长串的 <strong>ID</strong>、<strong>作者</strong>、<strong>日期</strong> 和提交的 <strong>信息</strong>。</p><p>既然我们需要回到上一版，也就是第一版，就需要用到第一版的 <strong>ID</strong>。</p><p><strong>ID</strong> 有 40 位，其实并不用全部打上去，只需要开头 5 位即可。</p><p>我们需要用到检出命令：<code>git checkout</code>。</p><img src="/Basic-Operation/08.webp" class=""><p>可以看见只需要第一版开头的 5 位 <strong>ID</strong> 就可以执行检出了。现在文件的内容变成了 <code>第一版内容</code>。</p><p>如果想要返回最新的那版，可以运行 <code>git checkout master</code>。</p><img src="/Basic-Operation/09.webp" class=""><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有时候我们不想一些文件加入版本控制，比如在 Windows 系统上生成的临时文件、编译生成的中间文件、日志文件等，这时候就可以使用 <strong>.gitignore</strong>。</p><p>创建一个名为 <strong>.gitignore</strong> 的文件，里面可以添加比如：</p><blockquote><p># 忽略日志文件<br>*.log<br># 忽略目录<br>build/<br># 排除目录下特定的文件<br>test/*.o</p></blockquote><p><strong>.gitignore</strong> 文件本身需要添加进版本控制里面。</p><p>如果不想自己手动写，<a href="https://github.com/github/gitignore" target="_blank" rel="noopener" title="A collection of useful .gitignore templates">GitHub</a> 有各种语言的忽略列表。</p><p>拓展阅读：<br><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86" target="_blank" rel="noopener">Git - 重置揭密</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲了如何安装和配置 Git，现在来开始了解如何使用 Git。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://ljason.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ljason.cn/tags/Git/"/>
    
      <category term="基础" scheme="https://ljason.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git——安装与配置</title>
    <link href="https://ljason.cn/Install-Version-Control/"/>
    <id>https://ljason.cn/Install-Version-Control/</id>
    <published>2018-02-07T09:59:04.000Z</published>
    <updated>2020-04-28T16:36:31.100Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇了解了版本控制的类型、Git 相较其他版本控制的优点，接下来就来说说在 Ubuntu 中的安装和配置 Git。</p><a id="more"></a><h1 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h1><h2 id="无脑装"><a href="#无脑装" class="headerlink" title="无脑装"></a>无脑装</h2><p>sudo apt-get install git</p><h2 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h2><p>我个人更喜欢从源码安装软件，因为上面无脑装的软件版本可能会比较老旧，从源码安装可以安装到最新版的软件。</p><p>如果以前安装过 Git，可以通过 <code>git clone https://github.com/git/git.git</code> 获取最新的源码。</p><p>如果没安装过，可以在 <a href="https://github.com/git/git/releases" target="_blank" rel="noopener">https://github.com/git/git/releases</a> 下载到源码的压缩包（tar.gz）。</p><p>解压压缩包： <code>tar zxvf git-*.tar.gz</code>。</p><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -y install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev autoconf asciidoc xmlto docbook2x</span><br></pre></td></tr></table></figure><p>然后就开始编译安装了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> git-*</span><br><span class="line">make configure</span><br><span class="line">./configure</span><br><span class="line">make -j4 all doc info</span><br><span class="line">sudo make install install-doc install-html install-info</span><br></pre></td></tr></table></figure><p>在上面的命令中，<strong>-j4</strong>  表示用 4 个线程编译，如果你的 CPU 是 <em>四核八线程</em>，建议使用 <strong>-j8</strong>。</p><h1 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h1><p>首先配置用户名和邮箱：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"your name"</span></span><br><span class="line">git config --global user.email <span class="string">"your email"</span></span><br><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>如果你所在的环境需要通过代理来联网，可以这样设置：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http</span></span><br><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line"><span class="comment"># https</span></span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"><span class="comment"># socks5</span></span><br><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:1080'</span></span><br></pre></td></tr></table></figure><p>按照情况设置即可，取消代理是：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇了解了版本控制的类型、Git 相较其他版本控制的优点，接下来就来说说在 Ubuntu 中的安装和配置 Git。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://ljason.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ljason.cn/tags/Git/"/>
    
      <category term="版本控制" scheme="https://ljason.cn/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
      <category term="安装" scheme="https://ljason.cn/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="配置" scheme="https://ljason.cn/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Git——版本控制简介</title>
    <link href="https://ljason.cn/Version-Control-Introduction/"/>
    <id>https://ljason.cn/Version-Control-Introduction/</id>
    <published>2018-02-03T07:33:25.000Z</published>
    <updated>2020-04-28T16:36:31.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要用版本控制"><a href="#为什么要用版本控制" class="headerlink" title="为什么要用版本控制"></a>为什么要用版本控制</h1><p>以前，我做开发的时候，每做完一个功能或者一个阶段，就会备份一次。当时间长了，就会变成这样：</p><img src="/Version-Control-Introduction/00.webp" class=""><p>浪费空间不说，当想要回到某个版本的时候，就得一个一个打开看看，特别费时费力。</p><p>所以我就到处找方法解决这个难题，皇天不负苦心人，终于还是被我找到了解决方法，那就是 <strong>版本控制</strong>。</p><a id="more"></a><h1 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h1><blockquote><p>你可以把一个版本控制系统（缩写 VCS）理解为一个“数据库”，在需要的时候，它可以帮你完整地保存一个项目的快照。当你需要查看一个之前的快照（称之为“版本”）时，版本控制系统可以显示出当前版本与上一个版本之间的所有改动的细节。</p></blockquote><h1 id="版本控制有哪些类型"><a href="#版本控制有哪些类型" class="headerlink" title="版本控制有哪些类型"></a>版本控制有哪些类型</h1><h2 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h2><p>这种是只在本地计算机上存储所有文件。</p><img src="/Version-Control-Introduction/01.webp" class=""><h2 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h2><p>随着需求不断提高，本地版本控制系统的缺点越来越明显：无法多人开发。因为文件都存储在某一个人的计算机中，他人无法访问。</p><p>集中式版本控制系统应运而生。</p><img src="/Version-Control-Introduction/02.webp" class=""><p>当人们想编辑一个或多个文件时，只有最后一个文件被检索。这种设置不仅可以为需要这些文件的人提供文件访问权限，而且还可以提供他人的工作信息。</p><p>由于文件存储在一个单独的位置，每个人都需要共享这些文件，因此对文件所做的任何更改都会自动的与他人共享。</p><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>当然，集中式版本控制系统也有缺点：当服务器故障时，所有人都将无法工作。</p><p>现在面临着一个尴尬的局面：</p><ul><li>使用集中式版本控制系统，将面临服务器故障的风险；</li><li>使用本地版本控制系统，将无法进行团队协作。</li></ul><p>如果将两个系统合并在一起呢？分布式版本控制系统诞生了。</p><img src="/Version-Control-Introduction/03.webp" class=""><p>分布式版本控制系统具有本地版本控制系统的优点：</p><ul><li>进行本地更改，不需要时时与服务器进行连接；</li><li>不依赖存储在服务器中的文件。</li></ul><p>同时也有集中式版本控制系统的优点：</p><ul><li>工作的可重用性；</li><li>可协同工作，不依赖于存储在单个机器上的历史。</li></ul><p>分布式版本控制系统被设计成可用两种方式工作。它在本地存储每台机器上的文件和每个历史，并且在需要时将用户在本地所做的更改同步回服务器。这样便可以与他人共享这些更改以达到团队协作的目的。</p><h1 id="如何选择版本控制系统"><a href="#如何选择版本控制系统" class="headerlink" title="如何选择版本控制系统"></a>如何选择版本控制系统</h1><p>现在我们了解了版本控制系统有哪些类型，现在有很多版本控制系统，该如何选择呢？</p><p>Git 是一个相对比较新的软件，因此避免了许多其他版本控制系统的缺陷。</p><p>相较于其他版本控制系统，即使处理数百万个文件，使用 Git 执行的操作也只需几秒钟即可完成。其中的一个主要原因是 Git 处理文件的方式不同。</p><p>从概念上讲，大多数版本控制系统（CVS，Subversion等等）将数据视为一组文件，随着版本的增多而对其中的每一个进行更改。</p><img src="/Version-Control-Introduction/04.webp" class=""><p>相比之下，Git 则为文件快照，即整个文件的内容，而不是每个文件的版本之间的差异。每创建一个版本，都会创建一整个快照，但这并不会存储重复的文件：如果文件没有更改，则只保存文件的链接。这大大加快了 Git 处理的速度。</p><img src="/Version-Control-Introduction/05.webp" class=""><p>与其他版本控制系统相比，Git 尽可能的减少存储空间的浪费，同时又极大提高了处理的速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要用版本控制&quot;&gt;&lt;a href=&quot;#为什么要用版本控制&quot; class=&quot;headerlink&quot; title=&quot;为什么要用版本控制&quot;&gt;&lt;/a&gt;为什么要用版本控制&lt;/h1&gt;&lt;p&gt;以前，我做开发的时候，每做完一个功能或者一个阶段，就会备份一次。当时间长了，就会变成这样：&lt;/p&gt;
&lt;img src=&quot;/Version-Control-Introduction/00.webp&quot; class=&quot;&quot;&gt;

&lt;p&gt;浪费空间不说，当想要回到某个版本的时候，就得一个一个打开看看，特别费时费力。&lt;/p&gt;
&lt;p&gt;所以我就到处找方法解决这个难题，皇天不负苦心人，终于还是被我找到了解决方法，那就是 &lt;strong&gt;版本控制&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://ljason.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://ljason.cn/tags/Git/"/>
    
      <category term="版本控制" scheme="https://ljason.cn/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>玩转树莓派05——各种远程访问</title>
    <link href="https://ljason.cn/RaspberryPi-Fives/"/>
    <id>https://ljason.cn/RaspberryPi-Fives/</id>
    <published>2018-01-22T08:33:50.000Z</published>
    <updated>2020-04-28T16:36:31.644Z</updated>
    
    <content type="html"><![CDATA[<p>　　这个 <a href="/categories/树莓派/">系列</a> 距离上一篇 <a href="/2016/04/14/RaspberryPi-Four.html">远程访问</a> 已经过去9个多月了。我家早已换上了光纤，也早已不需要远程访问了。但今天一时兴起又研究起了这个课题。  </p><a id="more"></a><p>　　首先把系统升级到最新：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y update</span><br><span class="line">sudo apt -y upgrade</span><br><span class="line">sudo apt -y dist-upgrade</span><br><span class="line">sudo apt autoremove</span><br><span class="line">sudo rpi-update</span><br></pre></td></tr></table></figure><h2 id="Weavedconnectd"><a href="#Weavedconnectd" class="headerlink" title="Weavedconnectd"></a>Weavedconnectd</h2><p>　　如果你用的是最新的官方 Raspbian 系统，那直接安装即可，其他版本及其他系统，参阅 <a href="https://github.com/weaved/installer/tree/master/Raspbian%20deb/1.3-07" target="_blank" rel="noopener">To install Weaved to your ARM Debian system</a> ，现在执行：  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y <span class="keyword">install</span> weavedconnectd</span><br></pre></td></tr></table></figure><p>　　安装完执行 <strong>sudo weavedinstaller</strong> 来启动交互式安装程序。初始化之后将会看见：  </p><center>    <p><img src="/images/RaspberryPi/Fives/00.webp" align="center"></p></center><p>　　如果没有账号，选择 <strong>2</strong> ，输入邮箱之后会给你的邮箱发送一个验证码，然后选择 <strong>3</strong> 输入验证码，然后输入两次密码即可创建一个新账户。</p><p>　　如果已经有账号了，选择 <strong>1</strong> 输入邮箱，然后输入密码即可。第一次登录会让你输入一个设备名：  </p><center>    <p><img src="/images/RaspberryPi/Fives/01.webp" align="center"></p></center><p>　　完了以后就进入主菜单了：  </p><center>    <p><img src="/images/RaspberryPi/Fives/02.webp" align="center"></p></center><p>　　这里选择 <strong>1</strong>，然后进入协议选择菜单：  </p><center>    <p><img src="/images/RaspberryPi/Fives/03.webp" align="center"></p></center><p>　　这里选择要连接的服务，<strong>1</strong> - <strong>3</strong> 都是常用的服务，<strong>4</strong> 是自定义服务。这里选择 <strong>1</strong>，<br>选完会提示你是否要使用 SSH 服务的默认端口（默认为 22）。如果没更改 SSH 的端口，选 Y 即可，自行选择。  </p><center>    <p><img src="/images/RaspberryPi/Fives/04.webp" align="center"></p></center><p>　　给服务一个名字即可。最后又回到主菜单，在主菜单上面有已经安装的服务：  </p><center>    <p><img src="/images/RaspberryPi/Fives/05.webp" align="center"></p></center><p>　　如果还想添加可以继续添加，添加完了选 <strong>4</strong> 退出即可。在树莓派上已经配置完了，现在看看怎么使用。  </p><p>　　在 <a href="https://www.remot3.it/app/index.html" target="_blank" rel="noopener">https://www.remot3.it/app/index.html</a> 登录刚刚注册的账号，在左侧点击 <strong>Manage Devices</strong> ，即可看见刚刚配置的树莓派。点击设备名，再点击下面的服务名，提示 <code>Press Confirm to connect &#39;Pi-SSH&#39;</code> ，点击 Confirm。  </p><center>    <p><img src="/images/RaspberryPi/Fives/06.webp" align="center"></p></center><p>　　可以使用域名和端口进行登录，也可以直接使用下方的命令在终端里登录。  </p><center>    <p><img src="/images/RaspberryPi/Fives/07.webp" align="center"></p></center><p>　　如果是 Web 服务，将会直接打开网页。  </p><h2 id="Dataplicity"><a href="#Dataplicity" class="headerlink" title="Dataplicity"></a>Dataplicity</h2><p>　　打开 <a href="https://dataplicity.com/" target="_blank" rel="noopener">https://dataplicity.com/</a> ，输入邮箱点击 <strong>Start</strong> ，把下方出现的一行命令复制粘贴进树莓派里面执行。执行期间可以上你的邮箱去验证账户。树莓派执行完回到页面点击 <strong>Done</strong> 。然后就连上树莓派了。。。   _(:зゝ∠)_</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　这个 &lt;a href=&quot;/categories/树莓派/&quot;&gt;系列&lt;/a&gt; 距离上一篇 &lt;a href=&quot;/2016/04/14/RaspberryPi-Four.html&quot;&gt;远程访问&lt;/a&gt; 已经过去9个多月了。我家早已换上了光纤，也早已不需要远程访问了。但今天一时兴起又研究起了这个课题。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="树莓派" scheme="https://ljason.cn/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="树莓派" scheme="https://ljason.cn/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="RaspberryPi" scheme="https://ljason.cn/tags/RaspberryPi/"/>
    
      <category term="远程访问" scheme="https://ljason.cn/tags/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 下 Android 设备连接 USB 提示 “no permissions”</title>
    <link href="https://ljason.cn/Enable-Android-device-USB-on-Linux/"/>
    <id>https://ljason.cn/Enable-Android-device-USB-on-Linux/</id>
    <published>2018-01-20T14:02:03.000Z</published>
    <updated>2020-04-28T16:36:32.068Z</updated>
    
    <content type="html"><![CDATA[<p>　　先在终端执行 <code>lsusb</code> ，然后插上 USB 再执行一遍，确定第二次多出来的设备就是新插上的 Android 设备。</p><a id="more"></a><img src="/Enable-Android-device-USB-on-Linux/00.webp" class=""><p>　　然后运行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/etc/udev/rules.d</span></span><br><span class="line"><span class="comment"># XX 是数字，MyDevice 是名字</span></span><br><span class="line">sudo vi XX-MyDevice.rules</span><br></pre></td></tr></table></figure><p>　　在里面写上刚刚的设备 ID ：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SUBSYSTEM</span>==<span class="string">"usb"</span>, ATTRS&#123;idVendor&#125;==<span class="string">"18d1"</span>,ATTRS&#123;idProduct&#125;==<span class="string">"4ee7"</span>,MODE=<span class="string">"0666"</span></span><br></pre></td></tr></table></figure><p>　　然后运行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">systemctl</span> <span class="selector-tag">restart</span> <span class="selector-tag">udev</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure><p>　　重新插拔即可看见新设备了，在 Android Studio 里面也可以看见了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　先在终端执行 &lt;code&gt;lsusb&lt;/code&gt; ，然后插上 USB 再执行一遍，确定第二次多出来的设备就是新插上的 Android 设备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://ljason.cn/categories/Linux/"/>
    
    
      <category term="Android" scheme="https://ljason.cn/tags/Android/"/>
    
      <category term="Linux" scheme="https://ljason.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Win10 上从此电脑删除“3D对象”</title>
    <link href="https://ljason.cn/Remove-3D-Objects-Folder/"/>
    <id>https://ljason.cn/Remove-3D-Objects-Folder/</id>
    <published>2017-11-01T16:32:53.000Z</published>
    <updated>2020-04-28T16:36:30.612Z</updated>
    
    <content type="html"><![CDATA[<p>　　Windows 10 的 “<a href="https://www.howtogeek.com/306610/whats-new-in-windows-10s-fall-creators-update/" target="_blank" rel="noopener">秋季创作者更新</a>” 将 <code>3D 对象</code> 文件夹添加到了 <strong>此电脑</strong> 里，甚至出现在了文件资源管理器的侧栏中。微软显然正在努力推广 Paint 3D 和 Windows 10 的其他新功能，但如果你不喜欢它，可以隐藏该文件夹，只需要修改注册表。</p><p>　　这不会在你的电脑上删除该文件夹，<code>3D 对象</code>文件夹仍然在 <code>C:\Users\NAME\3D Objects</code>，其中 <em>NAME</em> 是你的 Windows 账户名称。这仅仅是把它从文件资源管理器的侧栏中删除了它。</p><p>　　你也可以从 <strong>此电脑</strong> 中删除其他文件夹，但我们认为其他文件夹非常有用。只是 <code>3D 对象</code> 文件夹可能对大多数人都没有用。</p><a id="more"></a><h1 id="手动通过注册表删除-3D-对象"><a href="#手动通过注册表删除-3D-对象" class="headerlink" title="手动通过注册表删除 3D 对象"></a>手动通过注册表删除 <code>3D 对象</code></h1><p>　　你必须编辑注册表才能执行此操作。这是我们正式的警告：<strong>注册表编辑器是一个强大的工具，滥用它可能会使你的系统不稳定甚至无法使用！</strong> 这篇文章是非常简单的教程，只要你严格按照步骤做就应该不会有任何问题。也就是说，如果以前从未使用过它，请考虑在使用前阅读有关注册表编辑器的<a href="https://www.howtogeek.com/school/using-windows-admin-tools-like-a-pro/lesson5/" target="_blank" rel="noopener" title="如何使用注册表编辑器">相关知识</a>。在开始编辑之前，请备份好你的注册表（和系统）。</p><p>　　通过单击开始，键入 “<strong>regedit</strong>” 并按回车键打开注册表编辑器。给予权限以更改电脑。</p><p>　　首先，转到以下路径，可以复制路径粘贴到地址栏或者手动导航：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机<span class="symbol">\H</span>KEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\E</span>xplorer<span class="symbol">\M</span>yComputer<span class="symbol">\N</span>ameSpace</span><br></pre></td></tr></table></figure><p>　　在左边窗口中的 <strong>NameSpace</strong> 下找到 <strong>{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}</strong> 子项，右键删除即可。</p><img src="/Remove-3D-Objects-Folder/00.webp" class=""><p>　　然后，转到以下路径，可以复制路径粘贴到地址栏或者手动导航：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机<span class="symbol">\H</span>KEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\W</span>ow6432Node<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows<span class="symbol">\C</span>urrentVersion<span class="symbol">\E</span>xplorer<span class="symbol">\M</span>yComputer<span class="symbol">\N</span>ameSpace</span><br></pre></td></tr></table></figure><p>　　如果你的电脑上没有 <strong>WOW6432Node</strong> 键，则使用的是 32 位的系统，以下内容不用做。如果有这个键，则使用的是 64 位的系统，可以继续看下去。</p><p>　　再次在左边窗口中的 <strong>NameSpace</strong> 下找到 <strong>{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}</strong> 子项，右键删除。</p><p>　　你现在已经把 <code>3D 对象</code> 从此电脑和文件管理器侧边栏删除了。不必重启电脑，但是如果 <code>3D 对象</code> 没有消失，则请重启电脑。</p><p>　　如果想要还原，只需要在相同的位置创建 <strong>{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}</strong> 子项即可。</p><h1 id="通过一键注册表自动删除"><a href="#通过一键注册表自动删除" class="headerlink" title="通过一键注册表自动删除"></a>通过一键注册表自动删除</h1><p>　　如果你不想自己编辑注册表，可以下载注册表脚本一键删除。我们创建了删除该文件夹并恢复的脚本，有 64 位和 32 位的版本。</p><ul><li><a href="/Remove-3D-Objects-Folder/%E5%88%A0%E9%99%A43D%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%A4%B9-32%E4%BD%8D.reg" title="删除3D对象文件夹-32位.reg">删除3D对象文件夹-32位.reg</a></li><li><a href="/Remove-3D-Objects-Folder/%E5%88%A0%E9%99%A43D%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%A4%B9-64%E4%BD%8D.reg" title="删除3D对象文件夹-64位.reg">删除3D对象文件夹-64位.reg</a></li><li><a href="/Remove-3D-Objects-Folder/%E6%81%A2%E5%A4%8D3D%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%A4%B9-32%E4%BD%8D.reg" title="恢复3D对象文件夹-32位.reg">恢复3D对象文件夹-32位.reg</a></li><li><a href="/Remove-3D-Objects-Folder/%E6%81%A2%E5%A4%8D3D%E5%AF%B9%E8%B1%A1%E6%96%87%E4%BB%B6%E5%A4%B9-64%E4%BD%8D.reg" title="恢复3D对象文件夹-64位.reg">恢复3D对象文件夹-64位.reg</a></li></ul><p>　　只需下载对应的脚本并双击导入即可。</p><p>LJason 译</p><p>原文：<a href="https://www.howtogeek.com/331361/how-to-remove-the-3d-objects-folder-from-this-pc-on-windows-10/" target="_blank" rel="noopener">How to Remove “3D Objects” From This PC on Windows 10</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　Windows 10 的 “&lt;a href=&quot;https://www.howtogeek.com/306610/whats-new-in-windows-10s-fall-creators-update/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;秋季创作者更新&lt;/a&gt;” 将 &lt;code&gt;3D 对象&lt;/code&gt; 文件夹添加到了 &lt;strong&gt;此电脑&lt;/strong&gt; 里，甚至出现在了文件资源管理器的侧栏中。微软显然正在努力推广 Paint 3D 和 Windows 10 的其他新功能，但如果你不喜欢它，可以隐藏该文件夹，只需要修改注册表。&lt;/p&gt;
&lt;p&gt;　　这不会在你的电脑上删除该文件夹，&lt;code&gt;3D 对象&lt;/code&gt;文件夹仍然在 &lt;code&gt;C:\Users\NAME\3D Objects&lt;/code&gt;，其中 &lt;em&gt;NAME&lt;/em&gt; 是你的 Windows 账户名称。这仅仅是把它从文件资源管理器的侧栏中删除了它。&lt;/p&gt;
&lt;p&gt;　　你也可以从 &lt;strong&gt;此电脑&lt;/strong&gt; 中删除其他文件夹，但我们认为其他文件夹非常有用。只是 &lt;code&gt;3D 对象&lt;/code&gt; 文件夹可能对大多数人都没有用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Win10" scheme="https://ljason.cn/tags/Win10/"/>
    
      <category term="注册表" scheme="https://ljason.cn/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>ZeroNet 的安装和使用</title>
    <link href="https://ljason.cn/ZeroNet-Install-and-Use/"/>
    <id>https://ljason.cn/ZeroNet-Install-and-Use/</id>
    <published>2017-11-01T07:32:42.000Z</published>
    <updated>2020-04-28T16:36:32.048Z</updated>
    
    <content type="html"><![CDATA[<p>　　可能需要梯子，自行准备。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d <span class="params">--restart</span> always <span class="params">--name</span> zeronet -e <span class="string">"ENABLE_TOR=true"</span> -v ~<span class="string">/Documents/ZeroNet/data</span>:<span class="string">/root/data</span> -p 15441<span class="function">:15441</span> -p 43110<span class="function">:43110</span> nofish/zeronet</span><br></pre></td></tr></table></figure><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>　　下载并解压 ZeroNet：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="symbol">&lt;YouPath&gt;</span></span><br><span class="line">wget -<span class="keyword">c</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/HelloZeroNet/ZeroNet/archive/master.tar.gz</span><br><span class="line">tar xvpfz master.tar.gz</span><br><span class="line"><span class="keyword">cd</span> ZeroNet-master</span><br></pre></td></tr></table></figure><p>　　安装依赖：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> -y update &amp;&amp; sudo apt-<span class="builtin-name">get</span> -y<span class="built_in"> upgrade </span>&amp;&amp; sudo apt-<span class="builtin-name">get</span> -y dist-upgrade &amp;&amp; sudo apt-<span class="builtin-name">get</span> -y autoremove</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install -y msgpack-python python-gevent libevent-dev</span><br></pre></td></tr></table></figure><p>　　安装Tor：  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c <span class="string">'echo "deb http://deb.torproject.org/torproject.org $(lsb_release -cs) main" &gt;&gt; /etc/apt/sources.list.d/tor.list'</span></span><br><span class="line">gpg --keyserver keys.gnupg.net --recv 886DDD89</span><br><span class="line">gpg --<span class="builtin-name">export</span> A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | apt-key <span class="builtin-name">add</span> -</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> -y update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> install -y tor</span><br></pre></td></tr></table></figure><p>　　编辑 <em>/etc/tor/torrc</em>，在57行左右去掉<strong>“ControlPort 9051”</strong>和<strong>“CookieAuthentication 1”</strong>的注释。然后重启 Tor：  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/etc/</span>init.d/tor restart</span><br><span class="line">usermod -a -G debian-tor root</span><br></pre></td></tr></table></figure><p>　　如果在本机运行，直接运行：  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python</span> zeronet.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>　　然后打开 <a href="http://127.0.0.1:43110" target="_blank" rel="noopener">http://127.0.0.1:43110</a> 。</p><p>　　如果是在服务器搭建，运行：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">zeronet</span><span class="selector-class">.py</span> <span class="selector-tag">--ui_ip</span> 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>　　然后打开 <a href="http://ip:43110" target="_blank" rel="noopener">http://ip:43110</a></p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>　　下载 <a href="https://codeload.github.com/HelloZeroNet/ZeroNet-win/zip/dist" target="_blank" rel="noopener">ZeroNet-win-dist.zip</a> 解压，运行 ZeroNet.exe。</p><p>　　打开<a href="http://127.0.0.1:43110" target="_blank" rel="noopener">http://127.0.0.1:43110</a>。</p><p>　　推荐些站点：</p><p><a href="http://127.0.0.1:43110/1PLAYgDQboKojowD3kwdb3CtWmWaokXvfp/" target="_blank" rel="noopener">Play</a><br><a href="http://127.0.0.1:43110/1JTky29Dcq7hGKreBiYuQP9akSMiKwUrYx/" target="_blank" rel="noopener">Aengus 电影</a><br><a href="http://127.0.0.1:43110/keys.bit/" target="_blank" rel="noopener">神Key - 最有种的 Sync 资源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　可能需要梯子，自行准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ZeroNet" scheme="https://ljason.cn/categories/ZeroNet/"/>
    
    
      <category term="安装" scheme="https://ljason.cn/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="ZeroNet" scheme="https://ljason.cn/tags/ZeroNet/"/>
    
  </entry>
  
  <entry>
    <title>离线安装 Visual Studio 2017</title>
    <link href="https://ljason.cn/Offline-Installation-of-Visual-Studio-2017/"/>
    <id>https://ljason.cn/Offline-Installation-of-Visual-Studio-2017/</id>
    <published>2017-08-03T05:30:25.000Z</published>
    <updated>2020-04-28T16:36:31.860Z</updated>
    
    <content type="html"><![CDATA[<p>　　群里几个朋友都说安装 Visual Studio 2017 网速特别感人，所以我就 Google 了一下离线安装的方法。在这里记录一下方法，以便下次安装。  </p><a id="more"></a><h1 id="离线下载"><a href="#离线下载" class="headerlink" title="离线下载"></a>离线下载</h1><p>　　同样的，需要在 <a href="https://www.visualstudio.com/zh-hans/downloads/" target="_blank" rel="noopener">官网</a> 下载在线安装包 <strong>vs_community.exe</strong> 。  </p><p>　　然后在命令行里面运行：  </p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">D:</span>\vs_community.exe --layout <span class="string">"E:\VS2017"</span> --lang <span class="built_in">zh</span>-CN</span><br></pre></td></tr></table></figure><p>　　这样即可下载中文全部功能的离线包，<code>--layout</code> 是路径，<code>--lang</code> 是语言。如果不需要全部功能或者只需要某个特定功能（或者多语言），只需要使用 <code>--add</code> 命令即可，比如：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\vs_community<span class="selector-class">.exe</span> --layout <span class="string">"E:\VS2017"</span> --add Microsoft<span class="selector-class">.VisualStudio</span><span class="selector-class">.Workload</span><span class="selector-class">.ManagedDesktop</span> --add Microsoft<span class="selector-class">.VisualStudio</span><span class="selector-class">.Workload</span><span class="selector-class">.NetWeb</span> --lang zh-CN de-DE ja-JP</span><br></pre></td></tr></table></figure><p>　　具体命令行参数可以去 <a href="https://docs.microsoft.com/zh-cn/visualstudio/install/use-command-line-parameters-to-install-visual-studio" target="_blank" rel="noopener">使用命令行参数安装 Visual Studio 2017</a> 查看，这里给出各个工作组的代码：  </p><ol><li><p><code>Microsoft.VisualStudio.Workload.CoreEditor</code> Visual Studio 核心编辑器（Visual Studio Community 2017 内置）<br> Visual Studio 核心 shell 体验，包括语法感知代码编辑，源代码控制和工作项管理。  </p></li><li><p><code>Microsoft.VisualStudio.Workload.Azure</code> Azure 开发<br> 用于开发云应用程序和创建资源的 Azure SDK、工具和项目。  </p></li><li><p><code>Microsoft.VisualStudio.Workload.Data</code> 数据存储和处理<br> 使用 SQL Server、Azure Data Lake、Hadoop 或 Azure ML 连接、开发和测试数据解决方案。  </p></li><li><p><code>Microsoft.VisualStudio.Workload.DataScience</code> 数据科学与分析应用<br> 用于创建数据科学应用程序的语言和工具，包括 Python、R和F＃。  </p></li><li><p><code>Microsoft.VisualStudio.Workload.ManagedDesktop</code> .NET桌面开发<br> 使用 .NET Framework 构建 WPF，Windows Forms 和控制台应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.ManagedGame</code> Unity 游戏开发<br> 使用 Unity 创建 2D 和 3D 游戏，这是一个强大的跨平台开发环境。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NativeCrossPlat</code> 用 C++ 开发 Linux<br> 创建和调试在 Linux 环境中运行的应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NativeDesktop</code> 用 C++ 开发桌面程序<br> 使用 Visual C++ 工具集、ATL和可选功能（如 MFC 和 C++ / CLI）构建经典的基于 Windows 的应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NativeGame</code> 用 C++ 开发游戏<br> 使用 C++ 的全部功能构建由 DirectX、Unreal 或 Cocos2d 驱动的专业游戏。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NativeMobile</code> 用 C++ 进行移动开发<br>使用 C++ 构建 iOS、Android 或 Windows 的跨平台应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NetCoreTools</code> .NET Core 跨平台开发<br>使用 .NET Core、ASP.NET Core、HTML、JavaScript 和 CSS 构建跨平台应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NetCrossPlat</code> 使用 .NET 进行移动开发<br>使用 Xamarin 构建适用于 iOS、Android 或 Windows 的跨平台应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.NetWeb</code> ASP.NET 和 Web 开发<br>使用 ASP.NET、ASP.NET Core、HTML、JavaScript 和 CSS 构建 Web 应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.Node</code> Node.js 开发<br>使用 Node.js 构建可扩展的网络应用程序，即异步事件驱动的 JavaScript Runtime。</p></li><li><p><code>Microsoft.VisualStudio.Workload.Office</code> Office / SharePoint 开发<br>使用 C＃、VB 和 JavaScript 创建 Office 和 SharePoint 加载项、SharePoint 解决方案和 VSTO 加载项。</p></li><li><p><code>Microsoft.VisualStudio.Workload.Python</code> Python 开发<br>Python 的编辑、调试、交互式开发和源代码控制。</p></li><li><p><code>Microsoft.VisualStudio.Workload.Universal</code> 通用 Windows 平台开发<br>使用 C＃、VB、JavaScript 或可选的 C++ 创建通用 Windows 平台的应用程序。</p></li><li><p><code>Microsoft.VisualStudio.Workload.VisualStudioExtension</code> Visual Studio 扩展开发<br>为 Visual Studio 创建附加组件和扩展，包括新命令、代码分析器和工具窗口。</p></li><li><p><code>Microsoft.VisualStudio.Workload.WebCrossPlat</code> 使用 JavaScript 进行移动开发<br>使用 Apache Cordova 的工具构建 Android、iOS 和 UWP 应用程序。</p></li><li><p>无关联组件<br>这些是不在任何工作组中的组件，但可以选择为单独组件。</p><ol><li><code>Component.Android.Emulator</code> 适用于 Android 的 Visual Studio 模拟器</li><li><code>Component.GitHub.VisualStudio</code> GitHub 扩展</li><li><code>Microsoft.Component.Blend.SDK.WPF</code> Blend for Visual Studio SDK for .NET</li><li><code>Microsoft.Component.HelpViewer</code> Help Viewer</li><li><code>Microsoft.Net.Component.3.5.DeveloperTools</code> .NET Framework 3.5 开发工具</li><li><code>Microsoft.VisualStudio.Component.DependencyValidation.Community</code> Dependency Validation</li><li><code>Microsoft.VisualStudio.Component.LinqToSql</code>    LINQ to SQL tools</li><li><code>Microsoft.VisualStudio.Component.Phone.Emulator</code> Windows 10 Mobile 模拟器（周年纪念版）</li><li><code>Microsoft.VisualStudio.Component.TestTools.Core</code>    Testing tools core features</li><li><code>Microsoft.VisualStudio.Component.TypeScript.2.0</code>    TypeScript 2.0 SDK</li><li><code>Microsoft.VisualStudio.Component.TypeScript.2.1</code>    TypeScript 2.1 SDK</li></ol></li></ol><p>　　具体各个工作组包含的组件可以查看 <a href="https://docs.microsoft.com/zh-cn/visualstudio/install/workload-component-id-vs-community" target="_blank" rel="noopener">Visual Studio Community 2017 工作负载和组件 ID</a>。  </p><p>　　当我写完才发现原来是有中文版页面的 (╯‵□′)╯︵┻━┻ ，算了不改了。  </p><h1 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h1><p>　　等下载完就该安装了，继续在命令行里执行：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">E</span>:\<span class="selector-tag">VS2017</span>\<span class="selector-tag">vs_community</span><span class="selector-class">.exe</span> <span class="selector-tag">--add</span> <span class="selector-tag">Microsoft</span><span class="selector-class">.VisualStudio</span><span class="selector-class">.Workload</span><span class="selector-class">.ManagedDesktop</span> <span class="selector-tag">--add</span> <span class="selector-tag">Microsoft</span><span class="selector-class">.VisualStudio</span><span class="selector-class">.Workload</span><span class="selector-class">.NetWeb</span> <span class="selector-tag">--includeOptional</span></span><br></pre></td></tr></table></figure><p>　　这里要注意exe的路径是上面 <code>--layout</code> 路径里面的，中间的参数和上面创建离线包时的一样，后面加上 <code>--includeOptional</code> 即可。安装过程中也可以通过图形界面手动选择安装的选项。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　群里几个朋友都说安装 Visual Studio 2017 网速特别感人，所以我就 Google 了一下离线安装的方法。在这里记录一下方法，以便下次安装。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://ljason.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="离线安装" scheme="https://ljason.cn/tags/%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    
      <category term="Visual Studio" scheme="https://ljason.cn/tags/Visual-Studio/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建3——hexo</title>
    <link href="https://ljason.cn/Linux-SetUp-hexo/"/>
    <id>https://ljason.cn/Linux-SetUp-hexo/</id>
    <published>2017-06-28T16:00:00.000Z</published>
    <updated>2020-04-28T16:36:31.816Z</updated>
    
    <content type="html"><![CDATA[<p>　　其实在很久以前我的博客就改用 hexo 了，现在就来说说怎么装。</p><a id="more"></a><p>　　第一步还是安装 gcc：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install gcc g++</span><br></pre></td></tr></table></figure><h1 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h1><p>　　安装 node，<a href="../../../2016/06/22/Linux-SetUp-Jekyll.html" title="个人博客搭建2——Linux">上一篇</a>有讲，这里就不说了。</p><p>　　我写了个自动更新 node 的脚本，如果要用这个脚本还得先安装 jq：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> install -<span class="keyword">y</span> libonig-dev</span><br><span class="line"># 这里改成下载的路径</span><br><span class="line"><span class="keyword">cd</span> /mnt/storage/home/down</span><br><span class="line">rm -rf oniguruma</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/kkos/oniguruma.git &amp;&amp; <span class="keyword">cd</span> oniguruma/</span><br><span class="line">autoreconf -vfi &amp;&amp; ./configure</span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> .. &amp;&amp; rm -rf jq</span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/stedolan/jq.git &amp;&amp; <span class="keyword">cd</span> jq</span><br><span class="line">autoreconf -i &amp;&amp; ./configure --disable-maintainer-<span class="keyword">mode</span></span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure><p>　　接下来把脚本保存为 <code>AutoUpdateNode.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这句是配合 polipo 科学上网用的，如果下载 node 太慢就请使用 polipo 并取消注释</span></span><br><span class="line"><span class="comment"># export http_proxy=http://127.0.0.1:8123/ &amp;&amp; export https_proxy=http://127.0.0.1:8123/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里改成下载的路径</span></span><br><span class="line">path=/mnt/storage/home/down</span><br><span class="line">latest=$(curl https://nodejs.org/dist/index.json | jq <span class="string">".[0].version"</span> | sed <span class="string">'s/\"//g'</span>)</span><br><span class="line">node=$(node -v)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">install</span></span>()&#123;</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$path</span></span><br><span class="line">rm -rf node*</span><br><span class="line">wget -c https://nodejs.org/dist/<span class="variable">$latest</span><span class="string">"/node-<span class="variable">$latest</span>"</span>.tar.gz</span><br><span class="line">tar zxvf node-<span class="variable">$latest</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> node-<span class="variable">$latest</span>/</span><br><span class="line">./configure &amp;&amp; make &amp;&amp; make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$latest</span>"</span> != <span class="string">"<span class="variable">$node</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">install</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>　　给脚本添加可执行权限：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x <span class="regexp">/mnt/</span>storage<span class="regexp">/home/</span>script<span class="regexp">/AutoUpdateNode.sh</span></span><br></pre></td></tr></table></figure><p>　　添加定时更新，执行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>　　添加一行：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">6</span> * * * /mnt/storage/home/script/AutoUpdateNode.sh</span><br></pre></td></tr></table></figure><h1 id="安装-hexo（需要科学上网）"><a href="#安装-hexo（需要科学上网）" class="headerlink" title="安装 hexo（需要科学上网）"></a>安装 hexo（需要科学上网）</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>　　新建一个博客：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">init myBlog</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">myBlog/</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure><p>　　这样就新建好一个博客了，可以在 <code>source</code> 的 <code>_posts</code> 文件夹里面添加文章，用 markdown 写。</p><p>　　等添加完就可以生成静态网页了：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br></pre></td></tr></table></figure><p>　　有时候会出现一些奇奇怪怪的问题，就在生成静态页面之前删除之前的缓存即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">cl</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br></pre></td></tr></table></figure><p>　　写完博客玩魂2啦٩(๑&gt;◡&lt;๑)۶ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　其实在很久以前我的博客就改用 hexo 了，现在就来说说怎么装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客" scheme="https://ljason.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="教程" scheme="https://ljason.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Linux" scheme="https://ljason.cn/tags/Linux/"/>
    
      <category term="博客" scheme="https://ljason.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="https://ljason.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Windows 10 上安装和使用 Linux Bash Shell</title>
    <link href="https://ljason.cn/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/"/>
    <id>https://ljason.cn/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/</id>
    <published>2017-03-31T14:47:10.000Z</published>
    <updated>2020-04-28T16:36:30.768Z</updated>
    
    <content type="html"><![CDATA[<img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/00.webp" class=""><p>　　<a href="http://www.howtogeek.com/248177/whats-new-in-windows-10s-anniversary-update/" target="_blank" rel="noopener">Windows 10 的周年更新</a>为开发人员提供了一个巨大的新功能：一个完整的、基于 Ubuntu 的 Bash Shell，可以直接在 Windows 上运行 Linux 软件。这是微软通过添加新的 “Windows Subsystem for Linux”（Windows 的 Linux 子系统，下文简称 WSL） 实现的。</p><a id="more"></a><h2 id="有关-Windows-10-的-Bash-Shell"><a href="#有关-Windows-10-的-Bash-Shell" class="headerlink" title="有关 Windows 10 的 Bash Shell"></a>有关 Windows 10 的 Bash Shell</h2><p>　　这不是<a href="http://www.howtogeek.com/196060/beginner-geek-how-to-create-and-use-virtual-machines/" target="_blank" rel="noopener">虚拟机</a>、容器或为 Windows 编译的 Linux 软件（像 <a href="http://www.howtogeek.com/howto/41382/how-to-use-linux-commands-in-windows-with-cygwin/" target="_blank" rel="noopener">Cygwin</a>）。恰恰相反，Windows 10 获得了一个 Linux 子系统，它基于早已被微软遗弃的在 Windows 上运行 Android 应用的 Astoria 项目。</p><p>　　这可以认为和 <a href="http://www.howtogeek.com/105271/how-to-run-windows-software-on-ubuntu-with-wine/" target="_blank" rel="noopener">Wine</a> 相反。Wine 允许直接在 Linux 系统上运行 Windows 应用，WSL 可以在 Windows 上运行 Linux 应用。</p><p>　　微软已经和 Canonical 公司合作，致力于打造一个完整的、基于 Ubuntu 的、运行在这个子系统顶层的 Bash Shell。从技术层面上讲这完全不是 Linux。Linux 是底层操作系统内核，这在这里是不适用的。但是它运行的 Bash Shell 和二进制文件与 Ubuntu 上运行的完全相同。纯粹的自由软件主义者认为，一般的 Linux 操作系统应该被称为 “<a href="http://www.howtogeek.com/139287/the-great-debate-is-it-linux-or-gnulinux/" target="_blank" rel="noopener">GNU/Linux</a>”，因为它真的是有很多 GNU 软件在 Linux 内核上运行。你得到的 Bash Shell 只是 GNU 工具和其他软件而已。</p><p>　　但是这里有一些限制：无法运行服务器软件、不能运行带图形界面的软件，它只适用于想在 Windows 上运行 Linux 命令的程序猿。这些应用程序可以访问 Windows 文件系统，但不能使用 Bash 命令来自动化正常的 Windows 程序，或从标准的 Windows 命令来启动 Bash 命令。仅仅是可以访问相同的 Windows 文件系统，仅此而已。不是每个命令行程序都可以正常工作，因为 WSL 仍处在测试阶段。</p><h2 id="如何在-Windows-10-安装-Bash"><a href="#如何在-Windows-10-安装-Bash" class="headerlink" title="如何在 Windows 10 安装 Bash"></a>如何在 Windows 10 安装 Bash</h2><p>　　在这之前，请确保已经安装 Windows 10 周年版或者更新。这里只适用于 64位的 Windows 系统，如果您仍使用32位的系统，那是时候<a href="http://www.howtogeek.com/228042/how-to-switch-from-32-bit-windows-10-to-64-bit-windows-10/" target="_blank" rel="noopener">用64位的 Windows 10 系统</a>了。</p><p>　　当确定使用的是正确的 Win10 版本后，打开 <strong>“应用”</strong>，然后转到 <strong>“更新和安全”</strong> &gt; <strong>“针对开发人员”</strong>，在这里选择 <strong>“开发人员模式”</strong>。</p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/01.webp" class=""><p>　　接下来打卡控制面板，单击 <strong>“程序”</strong>，然后单击 <strong>“程序和功能”</strong> 下的 <strong>“打开或关闭 Windows 功能”</strong>。在列表中勾选 <strong>“适用于 Linux 的 Windows 子系统（Beta）”</strong>，然后单击 <strong>“确定”</strong>。</p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/02.webp" class=""><p>　　完成后系统会提示您重启计算机，单击 <strong>“立即重新启动”</strong>，Windows 10 将会安装新功能。</p><p>　　重启计算机之后，单击开始按钮（或按 Win 键），输入 <strong>“bash”</strong> 后回车。</p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/03.webp" class=""><p>　　当您第一次运行 bash.exe 文件时，系统将提示您接受服务条款，然后该命令将从 Windows 应用商店下载 <strong>“Bash on Ubuntu on Windows”</strong> 程序。之后系统会要求您创建用于在 Bash 环境中使用的用户账户和密码（注：不是 Windows 系统的账号密码）。</p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/04.webp" class=""><p>　　如果您想要自动化安装 Bash，可以在命令提示符窗口运行以下命令。这将自动同意所有提示，并且将默认用户设置为 “root”，不使用密码：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lxrun <span class="string">/install</span> <span class="string">/y</span></span><br></pre></td></tr></table></figure><h2 id="如何使用-Ubuntu-的-Bash-Shell-并且安装-Linux-软件"><a href="#如何使用-Ubuntu-的-Bash-Shell-并且安装-Linux-软件" class="headerlink" title="如何使用 Ubuntu 的 Bash Shell 并且安装 Linux 软件"></a>如何使用 Ubuntu 的 Bash Shell 并且安装 Linux 软件</h2><p>　　你现在有一个完整的基于 Ubuntu 的 Bash shell 了。由于它和 Ubuntu 使用的是相同的二进制文件，所以您可以使用 Ubuntu 的 <strong>“apt-get”</strong> 命令从 Ubuntu 的软件源安装软件。您可以运行 Linux 所有的命令，虽然不是每个命令都可以正常运行——特别是最初的测试版本。</p><p>　　要打开 Bash shell，只需要在你的开始菜单搜索 <strong>“bash”</strong> 或 <strong>“Ubuntu”</strong>。你会看到一个 <strong>“Bash on Ubuntu on Windows”</strong> 的程序（注：由于旧版中文的 Win10 系统会将英文的符号 <strong>“.”</strong> 换成 <strong>“。”</strong>，所以原本的快捷方式就失效了。可以去 <strong>“C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs”</strong> 中手动将 <strong>“Windows 中的 Bash on Ubuntu。lnk”</strong> 重命名 <strong>“Windows 中的 Bash on Ubuntu.lnk”</strong> ，回车即可看见白色的未知图标变成了 Ubuntu，创意者更新则没有此问题）。您可以将此快捷方式固定到您的开始菜单、任务栏或者桌面，以方便访问。</p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/05.webp" class=""><p>　　如果你有在 Linux、Mac OS 或其他平台使用 Bash shell 的经验，你就会用的得心应手。你不需要使用 <strong>“<a href="http://www.howtogeek.com/111479/htg-explains-whats-the-difference-between-sudo-su/" target="_blank" rel="noopener">sudo</a>”</strong> 了，因为你已经是 root 用户了。在 UNIX 平台上，<strong>“root”</strong> 用户具有绝对的系统访问权限，就像 Windows 上的 <strong>“Administrator”</strong> 用户一样。在 Bash shell 环境中您的 Windows 文件系统位于 /mnt/c 中。</p><p>　　它和 Linux 终端的用法一样，如果你熟悉标准 Windows 的 DOS 命令，这里有一下相似的基本命令：</p><ul><li>改变目录<ul><li>Bash：<strong>cd</strong></li><li>DOS：<strong>cd</strong> 或 <strong>chdir</strong></li></ul></li><li>列出目录内容<ul><li>Bash：<strong>ls</strong></li><li>DOS：<strong>dir</strong></li></ul></li><li>移动或重命名<ul><li>Bash：<strong>mv</strong></li><li>DOS：<strong>move</strong> 和 <strong>rename</strong></li></ul></li><li>复制文件<ul><li>Bash：<strong>cp</strong></li><li>DOS：<strong>copy</strong></li></ul></li><li>删除文件<ul><li>Bash：<strong>rm</strong></li><li>DOS：<strong>del</strong> 或 <strong>erase</strong></li></ul></li><li>创建目录<ul><li>Bash：<strong>mkdir</strong></li><li>DOS：<strong>mkdir</strong></li></ul></li><li>编辑文件<ul><li>Bash：<strong>vi</strong> 或 <strong>nano</strong></li><li>DOS：<strong>edit</strong></li></ul></li></ul><p>　　有个很重要的需要记住，WSL 不像 Windows ，Bash Shell 和 它的 Linux 环境是区分大小写的。换句话说，大写字母开头的 “File.txt” 和 小写开头的 “file.txt” 是两个不同的文件。</p><p>　　更多相关说明请参阅我们的 <a href="http://www.howtogeek.com/140679/beginner-geek-how-to-start-using-the-linux-terminal/" target="_blank" rel="noopener">Linux 命令初级指南</a> 和其他类似介绍 Bash Shell、Ubuntu 命令和 Linux 终端的资料。  </p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/06.webp" class=""><p>　　你需要使用 <a href="http://www.howtogeek.com/63997/how-to-install-programs-in-ubuntu-in-the-command-line/" target="_blank" rel="noopener">apt-get</a> 命令来安装和更新 Ubuntu 环境，并确保在这些命令前加上 <strong>“sudo”</strong>，这个命令可以使它以 root 用户的身份运行——就像 Windows 的 Administrator。这里有一些需要知道的：</p><ul><li>下载可更新包的更新信息：<strong>sudo apt-get update</strong></li><li>安装应用程序：<strong>sudo apt-get install <em>包名</em></strong></li><li>卸载应用程序：<strong>sudo apt-get remove <em>包名</em></strong></li><li>搜索可用的软件：<strong>sudo apt-cache search <em>关键字</em></strong></li><li>下载并安装升级包：<strong>sudo apt-get upgrade</strong></li></ul><p>　　下载并安装应用程序后，可以在提示符处键入其名称，然后按 <em>Enter</em> 运行。检查特定应用程序的文档以获取更多详细信息。  </p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/07.webp" class=""><h2 id="福利：安装-Ubuntu-字体以获得真正的-Ubuntu-体验"><a href="#福利：安装-Ubuntu-字体以获得真正的-Ubuntu-体验" class="headerlink" title="福利：安装 Ubuntu 字体以获得真正的 Ubuntu 体验##"></a>福利：安装 Ubuntu 字体以获得真正的 Ubuntu 体验##</h2><p>　　如果想在 Win10 上获得更爽的 Ubuntu 体验，还可以安装 Ubuntu 字体并在终端中启用它们。</p><p>　　从 <a href="http://font.ubuntu.com/" target="_blank" rel="noopener">Ubuntu 的网站</a> 上下载 Ubuntu 系列字体。打开下载的 zip 文件，找到 <strong>UbuntuMono-R.ttf</strong> 文件，这个是 Ubuntu 等宽字体，终端中使用的唯一一种字体，也是唯一需要安装的字体。  </p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/08.webp" class=""><p>　　双击 <strong>UbuntuMono-R.ttf</strong> 文件，您将看到该字体的预览，单击 “安装” 将其安装在系统上。  </p><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/09.webp" class=""><p>　　要使 Ubuntu 等宽字体成为控制台中的一个选项，您需要向Windows注册表添加一个设置：</p><ol><li><p>Win + R 打开注册表编辑器，键入 <strong>regedit</strong>，然后按回车，导航到以下项：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE<span class="symbol">\S</span>OFTWARE<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indows NT<span class="symbol">\C</span>urrentVersion<span class="symbol">\C</span>onsole<span class="symbol">\T</span>rueTypeFont</span><br></pre></td></tr></table></figure></li><li><p>右键单击右窗格并选择新建 &gt; 字符串值，命名为 <strong>000</strong>。</p></li><li><p>双击刚刚创建的 <strong>000</strong> 字符串，并输入 <strong>Ubuntu Mono</strong> 作为其值数据。  </p></li></ol><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/10.webp" class=""><ol start="4"><li>启动 Bash，右键单击标题栏，然后选择“属性”。单击“字体”选项卡，然后在字体列表中选择“Ubuntu Mono”。  </li></ol><img src="/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/11.webp" class=""><p>　　记住，安装在 Bash shell 中的软件仅限于 Bash shell。您无法从命令提示符，PowerShell 或 Windows 中的其他位置访问它。Bash shell 中的软件也不能与 Windows 程序直接交互或启动，尽管 Bash 环境和 Windows 可以访问您计算机上相同的文件。</p><p>　　但是，您可以创建 Bash shell 脚本（.sh脚本）并使用 Bash shell 运行它们。</p><p>LJason 译</p><p>原文：<a href="http://www.howtogeek.com/249966/how-to-install-and-use-the-linux-bash-shell-on-windows-10/" target="_blank" rel="noopener">How to Install and Use the Linux Bash Shell on Windows 10</a></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/How-to-Install-and-Use-the-Linux-Bash-Shell-on-Windows-10/00.webp&quot; class=&quot;&quot;&gt;

&lt;p&gt;　　&lt;a href=&quot;http://www.howtogeek.com/248177/whats-new-in-windows-10s-anniversary-update/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Windows 10 的周年更新&lt;/a&gt;为开发人员提供了一个巨大的新功能：一个完整的、基于 Ubuntu 的 Bash Shell，可以直接在 Windows 上运行 Linux 软件。这是微软通过添加新的 “Windows Subsystem for Linux”（Windows 的 Linux 子系统，下文简称 WSL） 实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Win10" scheme="https://ljason.cn/tags/Win10/"/>
    
      <category term="WSL" scheme="https://ljason.cn/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下安装 IntelliJ IDEA</title>
    <link href="https://ljason.cn/Linux-SetUp-IntelliJ-IDEA/"/>
    <id>https://ljason.cn/Linux-SetUp-IntelliJ-IDEA/</id>
    <published>2016-12-20T16:00:00.000Z</published>
    <updated>2020-04-28T16:36:30.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h1><p>　　1. 将下载的 IntelliJ IDEA 压缩文件解压到你希望安装的位置，下面会把这个位置称为 <code>{installation home}</code>。  </p><p>　　2. 在命令行中 cd 到 <code>{installation home}/bin</code>，执行以下命令来启动程序：  </p><a id="more"></a><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./idea.sh</span></span><br></pre></td></tr></table></figure><p>　　这将在 <code>~/.IntelliJIdeaXXXX.X</code> 文件夹中初始化配置文件。  </p><p>　　3. [可选] 将 <code>{installation home}/bin</code> 添加到 <code>PATH</code> 环境变量，以便可以从任意目录启动 IntelliJ IDEA。</p><p>　　4. [可选] 要调整 JVN 堆大小的值，请创建 <code>~/.IntelliJIdeaXXXX.X/idea.vmoptions</code> (如果使用 64位 JDK，则创建 <code>idea64.vmoptions</code>)，并且设置 <code>-Xms</code> 和 <code>-Xmx</code> 参数。具体可以参考 <code>{installation home}/bin</code> 目录中的 <code>vmoptions</code> 文件作为模板。  </p><h1 id="可选-更改-config-和-system-目录的位置"><a href="#可选-更改-config-和-system-目录的位置" class="headerlink" title="[可选] 更改 config 和 system 目录的位置"></a>[可选] 更改 <code>config</code> 和 <code>system</code> 目录的位置</h1><p>　　默认情况下，IntelliJ IDEA 会将所有设置存储到 <code>~/.IntelliJIdeaXXXX.X/config</code> 目录下，并使用 <code>~/.IntelliJIdeaXXXX.X/system</code> 作为数据缓存。如果要更改这些设置：  </p><p>　　1. 在命令行 cd 到 <code>~/.IntelliJIdeaXXXX.X/</code>。</p><p>　　2. 创建 <code>idea.properties</code> 文件并在编辑器中打开。根据需要设置 <code>idea.system.path</code> 或者 <code>idea.config.path</code> 的变量，例如：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">idea.system.path</span>=~/custom/system  </span><br><span class="line"><span class="attr">idea.config.path</span>=~/custom/config</span><br></pre></td></tr></table></figure><p>　　3. 请注意，建议将数据缓存（<code>system</code> 目录）存储在至少有 1GB 可用空间的磁盘上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装说明&quot;&gt;&lt;a href=&quot;#安装说明&quot; class=&quot;headerlink&quot; title=&quot;安装说明&quot;&gt;&lt;/a&gt;安装说明&lt;/h1&gt;&lt;p&gt;　　1. 将下载的 IntelliJ IDEA 压缩文件解压到你希望安装的位置，下面会把这个位置称为 &lt;code&gt;{installation home}&lt;/code&gt;。  &lt;/p&gt;
&lt;p&gt;　　2. 在命令行中 cd 到 &lt;code&gt;{installation home}/bin&lt;/code&gt;，执行以下命令来启动程序：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://ljason.cn/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Linux" scheme="https://ljason.cn/tags/Linux/"/>
    
      <category term="翻译" scheme="https://ljason.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>C开发基础01——Hello World</title>
    <link href="https://ljason.cn/C-Develop-HelloWorld/"/>
    <id>https://ljason.cn/C-Develop-HelloWorld/</id>
    <published>2016-10-15T16:00:00.000Z</published>
    <updated>2020-04-28T16:36:30.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>　　作为编程语言的入门第一课，自然缺不了 Hello World 了。  </p><a id="more"></a><p>　　新建一个工程，默认是新建一个 <code>.cpp</code> 文件。可以新建文件，也可以直接重命名为 <code>.c</code>。写上：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">"Hello World"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这是最简单的一个C语言程序，将会在屏幕上打印一行：  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br></pre></td></tr></table></figure><p>　　接下来就来说说这个最简单的C语言的结构。  </p><h1 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h1><p>　　程序第一行的 stdio.h 是关于标准输入输出的头文件，C语言为文件输入输出提供了许多标准库函数，正是这些库函数构成了C标准库头文件 stdio.h 的主体，一般的C程序都离不开这个头文件。<code>#include</code> 语句表示包含头文件，有两种写法。分别是使用双引号 <code>&quot; &quot;</code> 和使用尖括号 <code>&lt; &gt;</code>。这两者是有区别的，主要是使用时头文件的搜索顺序不同。  </p><p>使用双引号 <code>&quot; &quot;</code> 时头文件的搜索顺序：  </p><ol><li>包含该#include语句的源文件所在目录；  </li><li>包含该#include语句的源文件的已经打开的头文件的逆序；  </li><li>编译选项-I所指定的目录；  </li><li>环境变量INCLUDE所定义的目录。  </li></ol><p>使用尖括号 <code>&lt; &gt;</code> 时头文件的搜索顺序：  </p><ol><li>编译选项-I所指定的目录；  </li><li>环境变量INCLUDE所定义的目录。  </li></ol><p>　　一般情况下，当我们需要包含系统自带的C标准库头文件时，两个都可以使用；但是当我们需要包含用户自己写的头文件的时候，就必须使用双引号 <code>&quot; &quot;</code> 了。所以，如果能够区分系统和用户的头文件，就各自用；当不能够区分时，用双引号 <code>&quot; &quot;</code> 也肯定不会错。  </p><p>　　<strong>注意： <code>#include</code> 是将已存在文件的内容嵌入到当前文件中。</strong>  </p><h1 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h1><p>　　main 表示主函数，所有的C程序都是由一个或多个函数构成，其中必须且只能有一个主函数 main。程序从主函数开始执行，相当于程序的入口，当执行到调用函数的语句时，程序将控制转移到调用函数中执行，执行结束后再返回主函数中继续运行，直至程序执行结束。  </p><h1 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h1><p>　　在函数后面的花括号 <code>{ }</code> 里面的内容就是函数体，在上面的例子中，<code>printf(&quot;Hello World&quot;);</code> 就是函数体。  </p><p>　　printf 函数是一个由系统定义的标准函数，可在程序中直接调用。printf 函数的功能是把要输出的内容（上面是Hello world!）打印出来。  </p><p>　　为了美观，C语言一般都是一个语句一行，语句最后必须跟一个分号 <code>;</code>，表示该语句的结束。分号称为终结符，单独一个分号也可构成一个语句，这就是空语句。如果不加分号，现代的IDE会马上提示错误无法编译。  </p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ul><li><p>行注释<br>　　在符号 <code>//</code> 后的那一行不会被编译。  </p></li><li><p>块注释<br>　　被块注释符号 <code>/ * 任意内容 * /</code> 中间的部分不会被编译。</p></li></ul><p>　　程序中表示对程序的说明（注释），可以方便程序的阅读。注释不参与程序的编译和运行，它可以加在程序的任何位置，注释文字可以是任意字符，如汉字、拼音、英文等。  </p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="../../09/28/C-Develop-SetUp-CLion.html">搭建C开发环境——在 Windows 下配置 CLion</a>  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h1&gt;&lt;p&gt;　　作为编程语言的入门第一课，自然缺不了 Hello World 了。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://ljason.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="教程" scheme="https://ljason.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://ljason.cn/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="C" scheme="https://ljason.cn/tags/C/"/>
    
      <category term="CLion" scheme="https://ljason.cn/tags/CLion/"/>
    
  </entry>
  
  <entry>
    <title>搭建C开发环境——在 Windows 下配置 CLion</title>
    <link href="https://ljason.cn/C-Develop-SetUp-CLion/"/>
    <id>https://ljason.cn/C-Develop-SetUp-CLion/</id>
    <published>2016-09-27T16:00:00.000Z</published>
    <updated>2020-04-28T16:36:30.584Z</updated>
    
    <content type="html"><![CDATA[<p>　　开始大学生活了，但是并没有想象中的高大上，课程依旧是中国式的“骨灰级”课程，所以只能靠自学和加入社团来填充苍白的精神世界和校园生活了。  </p><p>　　许多同学都来问我关于C语言的问题，所以打算写一点点基础性的东西帮助同学们入门，顺便也帮助我巩固这些基础。  </p><a id="more"></a><p>　　“骨灰级”的课程不出所料使用的是骨灰级的VC艹，其实我是非常厌恶守旧的。写C当然得用 JetBrains 高大上的 CLion。首先去<a href="https://www.jetbrains.com/clion/download/#section=windows-version" target="_blank" rel="noopener">官网</a>下载最新的 CLion，安装完之后先配置 MinGW 再打开 CLion。  </p><p>　　由于我们伟大的朝廷，MinGW 不是无法下载就是速度很慢，所以我把我使用的打包<a href="http://pan.baidu.com/s/1bo2TCV9" target="_blank" rel="noopener" title="密码：3esg">共享</a>出来了。解压到非中文目录，解压完再打开 CLion。  </p><p>　　按照自己喜好设置，然后设置 MinGW 的路径。</p><center>    <p><img src="/images/CDevelop/CLion/00.webp" align="center"></p></center><p>　　然后一直默认 Next。结束之后就可以 <code>New Project</code> 新建工程了。</p><center>    <p><img src="/images/CDevelop/CLion/01.webp" align="center"></p></center><p>　　至于破解方法，自己去 Google 吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　开始大学生活了，但是并没有想象中的高大上，课程依旧是中国式的“骨灰级”课程，所以只能靠自学和加入社团来填充苍白的精神世界和校园生活了。  &lt;/p&gt;
&lt;p&gt;　　许多同学都来问我关于C语言的问题，所以打算写一点点基础性的东西帮助同学们入门，顺便也帮助我巩固这些基础。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="C语言" scheme="https://ljason.cn/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="搭建" scheme="https://ljason.cn/tags/%E6%90%AD%E5%BB%BA/"/>
    
      <category term="环境" scheme="https://ljason.cn/tags/%E7%8E%AF%E5%A2%83/"/>
    
      <category term="教程" scheme="https://ljason.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C" scheme="https://ljason.cn/tags/C/"/>
    
      <category term="CLion" scheme="https://ljason.cn/tags/CLion/"/>
    
  </entry>
  
</feed>
